---
layout: page
title: Pro013
permalink: /pro013/
kramdown: 
  parse_block_html: true
---


<style>
h3 {
	margin-top: 25px;
}

.icono-alert {
	float: left;	
	margin-left: 5px;
}

.contenido-alert {
	margin-left: 30px;
}

.alert {
	margin-top: 25px;
}
</style>



* __Ciclo__: "Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Multiplataforma"
* __Módulo__: "Programación"
* __Curso__: 2013/2014
	* [Consultar faltas de asistencia](https://docs.google.com/a/iessanandres.com/spreadsheet/pub?key=0AojaZeMGL7HsdGYtYUNrOHBJWnlZZUJtS2d4cnNneUE&single=true&gid=10&output=html)
	* [Consultar las actividades presentadas](https://docs.google.com/spreadsheet/pub?key=0AojaZeMGL7HsdDduUWZwZmtCaEtYOENHNjhyMktURHc&single=true&gid=0&output=html)


<!--
### Abstracción y diseño modular

Para programar aplicaciones reales en Java o en cualquier otro lenguaje no es suficiente con crear objetos de una única clase. En los programas reales objetos de distintas clases se combinan y cooperan entre ellos para llevar a cabo una tarea. 

Para entenderlo vamos a pensar en la siguiente situación. Imaginemos que tenemos un amigo programador en Java como nosotros que quiere hacer una aplicación para Android consistente en un reloj en formato 24 horas, que muestre horas y minutos desde las 00:00 hasta las 23:59. Como anda muy apurado de tiempo, nos pide que le hagamos parte del trabajo. Concretamente necesita una clase llamada ClockDisplay que permita:

1. Fijar un momento determinado de tiempo expresado en horas y minutos, por ejemplo, las 23:45.
2. Hacer avanzar un minuto el tiempo fijado. Evidentemente este método se puede llamar tantas veces como se quiera.
3. Devolver una cadena de 5 caracteres consistente en la hora y los minutos separados por dos puntos.

Pausa el video e intenta codificar por tu cuenta esta clase.

¿Que tal, has conseguido codificar la clase? Yo voy ahora comentar posibles soluciones. La primera idea que se nos ocurre sin pensar demasiado es implementar nuestro reloj mediante una única clase. Sería algo así:

	public class Reloj
	{
	    private String tiempoActual;

	    public Reloj(String nuevoTiempoActual)
	    {
	        tiempoActual = nuevoTiempoActual;
	    }

	    
	    public String getTiempoActual()
	    {
	        return tiempoActual;
	    }
	    
	    public hacerPasarUnMinuto()
	    {
	        ??????????
	        tiempoActual = tiempoActual + 1; ????
	    }
	}

Nos encontramos con un problema cuando abordamos la implementación del último método. ¿Cómo podríamos hacer este método? La solución no es trivial aunque si quieres puedes intentar completarlala ahora. Yo voy a afrontar el problema desde otra perspectiva.

Los programadores, cuando intentamos encontrar la solución a un problema complejo, hacemos uso de la estrategia conocida como "divide y vencerás". Consiste en dividir un problema grange en subproblemas más pequeños y estos subproblemas pequeñis en subsubproblemas aún mas pequeños y seguir dividiendo hasta que los problemas resultantes sean fáciles de solucionar. 

Una vez que solucionamos uno de estos pequeños subproblemas entra en juego la abstracción, que consiste en ser consciente de como encajar esa pieza en el problema general sin preocuparnos de cómo se ha resuelto su funcionamiento interno. Este tipo de miniproblemas resueltos son como cajas negras, porque sabemos como interactuar con ellos pero no como funcionan internamente.

El mejor ejemplo de una caja negra es un coche. Simplificando un poco, cuando nos sentamos en un coche tenemos disponibles varias acciones: usar la llave para arrancar, girar el volante, pisar y soltar el acelerador, el freno y el embrague y subir y bajar marcha y usar la llave de nuevo para apagar. Cada acción que llevamos a cabo produce un resultado, pero no sabemos qué hace internamente el coche para conseguirlo.

Vamos a pensar en un ejemplo para aclarar qué es eso de la abstracción. Vamos a imaginar cómo trabajan los ingenieros de una marca de coches tipo Nissan o Toyota cuando se enfrentan a un problema: diseñar un nuevo modelo de coche. En principio está claro que se reparten el trabajo: unos diseñan unas partes del vehiculo y otros otras. Ahí ya estamos viendo el uso del divide y vencerás ya que los ingenieros están descomponiendo el problema original (que era diseñar todo el coche) en subproblemas más pequeños. Por ejemplo, un ingeniero se puede encargar de decidir la forma y medidas del coche o el número de asientos que tendrá. Otro ingeniero puede estar encargado de diseñar el motor. Otro puede estar encargado de diseñar las ruedas y así podríamos seguir con cada una de las piezas que componen un coche. Bueno, en realidad más que un ingeniero serán varios los que hagan cosas como diseñar el motor, pero vamos a pensar en uno solo para simplificar.

Vamos a fijarnos en algo como las ruedas. El ingeniero que diseña la forma del coche la consideran como una entidad completa. Sabe de ellas ciertos datos (como el diametro) y cómo acoplarlas al coche. En cierto modo podemos pensar que para este ingeniero una rueda es algo bastante simple. Sin embargo, para el ingeniero que ha diseñado las ruedas estas han sido algo realmente complejo: ha tenido que preocuparse de todas y de cada una de las medidas de la rueda, de estudiar que compuestos químicos eras los más adecuados para los neumáticos, del peso de cada uno de los componentes de la rueda, de hacer pruebas en laboratorio y en circuito para ver su respuesta en situaciones climatológicas adversas y de mil y una cosas más. Vemos que el ingeniero que diseña la forma del coche se abstrae de todos estos detalles y considera la rueda como algo más simple.

Lo mismo ocurre con el ingeniero que diseña el espacio interior del coche y con el ingeniero que se ocupa de diseñar cada asiento. Al primero le basta con saber las medidas de los asientos y como encajan en el habitáculo; para el segundo el asiento es algo muy complejo, ya que tiene que preocuparse de todas las piezas que intervienen, de la tapicería que llevan, de los mecanismos electrónicos y mecánicos para regularlos, de hacer pruebas de resistencia para soportar pasajeros pesados, etc. El ingeniero que diseña el habitáculo se abstrae de todos estos detalles y considera los asientos como piezas simples.

Si lo pensamos, un coche tiene tantos elementos que es imposible que un solo ingeniero sepa como funciona cada detalle de cada parte del coche. Por tanto, la razón de que tengamos coches circulando en las calles es que los ingenieros utilizan el divide y vencerás y la abstracción para ser capaces de diseñarlos. A la estrategia del divide y venecerás también la conocemos como diseño modular.

El diseño modular y la abstracción se complementan el uno al otro. El diseño modular es el proceso por el que problemas grandes se dividen en problemas más pequeños. La asbtracción es la habilidad que tenemos para ignorar los detalles de estos problemas más pequeños y poder tener verlos de manera más simple.

Los programadores utilizamos tambien estos principios de diseño modular y abstracción para desarrollar software. Cuando nos enfrentamos a un problema complejo, lo primero que hacemos es intentar identificar componentes del mismo que podamos programar como componentes individuales. Una vez desarrollados estos componentes individuales, podemos utilizarlos sin preocuparnos de toda la complejidad que encierran en su interior.

En la programación orientada a objetos, estos componentes son los objetos. Si estamos, por ejemplo, desarrollando un simulador de futbol, lo primero que haremos será detectar todos los objetos que están involucrados en el mismo y desarrollar cada componente de manera individual. Por ejemplo, podemos implementar una clase balón para tener un objeto balón, una clase jugador para tener 20 objetos jugador, una clase portero para tener 2 objetos portero, una clase espectador para tener en nuestro programa 100.000 espectadores, etc. Una vez que tenemos programado cada elemento por separado y hemos hecho test para comprobar que se comportan como nosotros queremos, podemos entonces ponerlos a funcionar conjuntamente. 

Identificar qué objetos y qué clases debemos tener en el desarrollo de un software que solucione un problema no siempre es trivial. Así que para empezar a familiarizarnos con esta forma de hacer programas, vamos a volver a nuestro ejemplo del reloj digital.

Ya hemos visto que nuestro amigo ha aplicado inicialmente el diseño modular dividiendo el problema en una clase ClockDisplay que es la que nos toca hacer a nosotros y el resto de tareas para que se muestre en un dispositivo Android que es lo que tiene que hacer él. También está haciendo uso de la abstracción, ya que para él, el objeto que nosotros vamos a programar hace unas determinadas cosas y no necesita preocuparse de que código hemos utlizado para conseguir que funcione.

Ahora nos toca a nosotros dividir el problema que nos han encomendado en subproblemas más pequeños y simples. Si nos fijamos, el reloj digital tiene dos partes, las horas y los minutos, que tienen un funcionamiento bastante similar: consisten en un par de números que empiezan en 00, se incrementan de 1 en 1 y cuando llegan a 24 en el caso de las horas o a 60 en el de los minutos, vuelven a 00. Este funcionamiento parecido hace que podamos abstraer unas propiedades comunes a la parte que representa las hora y a la parte que representa los minutos y pensar en crear una única clase que represente tanto a la zona de las horas como a la de los minutos.

Esta clase la vamos a llamar NumberDisplay y representa un display de dos dígitos que empieza en 00, se incrementa de 1 en 1 y al llegar a un determinado límite vuelve a 00. Necesitaremos crear varios métodos en esta clase: un método getter para obtener el valor actual del display, y dos métodos modificadores: uno para fijar a un determinado valor el display y otro para incrementarlo en 1. Una vez que tengamos definida la clase, nuestra clase ClockDisplay debería estar formada por dos objetos NumberDisplay con diferentes límites: 24 en el caso del display de la horas y 60 en el caso del display de los minutos

Ahora sería buena idea detenerte un momento y pensar qué atributos debe tener nuestra clase NumberDisplay y qué parámetro debe llevar el constructor de esta clase.

¿Ya lo has pensado? Yo voy a usar dos atributos de tipo entero: uno representará el valor actual del display y otro representará el valor límite del display, que será 24 en el caso de las horas y 60 en el caso de minutos.

	public class NumberDisplay
	{
		private int limit;
		private int value;
	}

En cuanto tengamos bien codificada esta clase podremos crear el reloj que nos pide nuestro amigo usando un objeto ClockDisplay que estará formado internamente por dos objetos de la clase NumberDisplay, uno para las horas y otro para los minutos.

No voy a codificar los métodos pero la clase ClockDisplay sería algo así

	public class ClockDisplay
	{
		private NumberDisplay hours;
		private NumberDisplay minutes;	
	}

Como vemos tenemos dos atributos, hours y minutes, que no son ni de tipo entero, ni de tipo String ni de ningún tipo de los que vienen con Java, sino que son de tipo NumberDisplay, que es una clase que hemos creado nosotros. Debemos quedarnos con la idea de que las clases que creamos se convierten en tipos de datos y podemos tener variables y atributos que sean de estos tipo de datos. Estos atributos que acabo de codificar lo que van a contener es un objeto de la clase NumberDisplay.
-->

### Actividad 0000

Codifica en BlueJ la clase `NumberDisplay`. A continuación se indica qué es necesario que, como mínimo, implemente dicha clase.:

* Un constructor que recibe por parámetro el límite del display y que fija el valor actual del display a 0.
* Un método setter que fija el valor actual del display al valor pasado como parámetro (nombre del método: `setValue`).
* Un método que devuelve el valor actual del display en forma de cadena de 2 caracteres (nombre del método: `getDisplayValue`).
* Un método que devuelve el valor actual del display como entero (nombre del método: `getValue`),
* Un método que incrementa en 1 al display y lo hace volver al principio si alcanza el límite (nombre del método: `increment`)


### Diagrama de objetos vs diagrama de clases

[Ver explicación en Youtube](http://youtu.be/C6FM6SeBLXY)

<!--
Imagina que podemos hacer una foto a un programa en ejecución y que podemos ver qué objetos existen en ese momento y qué relación hay entre ellos. Eso sería el diagrama de objetos. Decidimos que es algo dinámico porque va cambiando conforme avanza el tiempo, unos objetos se crean y otros se van destruyendo. Decimos que es un diagrama correspondiente al runtime, es decir, al tiempo de ejecución de un programa.

Por otro lado tenemos el diagrama de clases. Este diagrama es estático, no cambia. Podemos dibujarlo echando un vistazo al código fuente y viendo qué clases dependen de otras clases. Por ejemplo, si pensamos en la estrategia que he seguido para crear la clase ClockDisplay, tenemos que esa clase ClockDisplay depende de la clase NumberDisplay porque tiene dos atributos de la clase NumberDisplay.

Siguiendo con el ejemplo de la clase ClockDisplay, cuando creemos un objeto de esa clase en el constructor vamos a inicializar los dos atributos, es decir, vamos a crear dos objetos NumberDisplay. En ese momento, el diagrama de objetos tendría 3 objetos: uno de la clase ClockDisplay y dos de la clase NumberDisplay.

Viendo el diagrama de objetos nos tenemos que dar cuenta de una cosa muy importante. Cuando una variable o un atributo es de tipo NumberDisplay el objeto que contiene no se guarda directamente en esa variable. El objeto se crea en una zona de memoria y variable apunta a dicho objeto. En Java hablamos de que la variable o el atributo contiene una referencia al objeto en vez de el objeto en sí.

BlueJ nos muestra el diagrama de clases en su pantalla principal, pero con el tiempo nosotros tenemos que ser capaces de saber cómo sería el diagrama de objetos en cualquier momento de la ejecución de un programa.
-->



### Actividad 0001

1. Clona el proyecto `house` de mi página de GitHub, ábrelo con BlueJ y crea un objeto `picture`. Si nos olvidamos de la clase `Canvas`, dibuja en tu cuaderno cómo sería el diagrama de clases y de objetos en ese momento. 
2. Invoca ahora sobre el objeto que creaste el método `draw()`. Si nos olvidamos de la clase `Canvas`, dibuja en tu cuaderno cómo sería el diagrama de clases y de objetos en ese momento.

<div markdown="0">
<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0001">
Mostrar solucion
</button>
<div id="0001" class="collapse" markdown="1">

[Ver video en Youtube](http://youtu.be/If30QZqbMnM)

</div>
</div>



### Actividad 0002

Piensa en las respuestas a la siguientes preguntas: ¿en qué momento puede cambiar el diagrama de clases de una aplicación? ¿Qué tendríamos que hacer para cambiarlo? ¿En qué momento puede cambiar el diagrama de objetos de una aplicación? ¿Qué tendríamos que hacer para cambiarlo?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0002">
Mostrar solucion
</button>
<div id="0002" class="collapse">

* El diagrama de clases puede cambiar cuando cambia el código fuente.
* El diagrama de objetos cambia cuando creamos o eliminamos objetos durante el tiempo de ejecución.

</div>


### Actividad 0003

Escribe en tu cuaderno como sería la línea de código necesaria para definir en una clase un atributo llamado `tutor` que pueda almacenar una referencia a un objeto de la clase `Profesor`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0003">
Mostrar solucion
</button>
<div id="0003" class="collapse">
La definición del atributo sería:

{% highlight java %}
private Profesor tutor;
{% endhighlight %}	

</div>


### Tipos de datos primitivos vs tipos referenciados

[Ver explicación en Youtube](http://youtu.be/ukNV9hwJNhY)

<!--
En Java tenemos dos tipos de datos diferentes: los tipos primitivos por un lado y los tipos referenciados por otro. 

Los atributos de las clases, los parámetros de los métodos y las variables locales pueden ser tanto de un tipo de dato primitivo como de un tipo de dato referenciado. Los tipos de datos primitivos son por ejemplo `ìnt`, `float`, `boolean`, etc. Los tipos de datos referenciados son clases: bien las clases que ya trae Java, como por ejemplo `String` o bien las clases que nosotros creamos, por ejemplo `NumberDisplay`.

La diferencia es que cuando una variable contiene un tipo de dato primitivo, almacena su valor directamente. Si una variable es de tipo entero y vale 5, ese 5 está guardado dentro de la variable. En cambio, si una variable es de tipo referenciado, contendrá un objeto. Pero ojo, este objeto existirá en una zona de la memoria del ordenador fuera de la variable y lo que contendrá la variable será una referencia, es decir, una especie de flecha, a ese objeto.

Además, los tipos de datos primitivos no tienen métodos. Si tenemos una variable `a` de tipo entero, no podemos invocar ningún método sobre ella. En cambio, si tenemos una variable `b` de tipo referenciado `String`si que podemos invocar métodos del tipo `b.length()`.

Los tipos de datos primitivos siempre empiezan por minúscula como en `int` o `boolean` mientras que los tipos de datos referenciados siempre empiezan por mayúscula como en `String` o en `NumberDisplay`.
-->


### Tipos de datos primitivos

* Números enteros:
	* `byte`: números enteros que ocupan 8 bits (por ejemplo, `24` o `-2`)
	* `short`: números enteros que ocupan 16 bits (por ejemplo, `137` o `-119`)
	* `int`: números enteros que ocupan 32 bits (por ejemplo, `5409` o `-2003`)
	* `long`: números enteros que ocupan 64 bits (por ejemplo, `423266353L` o `55L`)

* Numeros decimales:
	* `float`: números decimales de precision simple (por ejemplo, `43.889F`)
	* `double`: números decimales de doble precisión (por ejemplo, `45.63` o `2.4e5`)

* Otros tipos:
	* `boolean`: almacena un valor booleano `true` o `false` (por ejemplo, `true` o `false`)
	* `char`: almacena un caracter en 16 bits (por ejemplo, `'m'` o `'?'`)

Notas:

* Un número sin punto decimal es interpretado como un entero. Java puede convertir enteros automáticamente a un tipo de dato entero más pequeño siempre que quepa en él. Sin embargo, Java no puede convertir automáticamente un entero a un `long`. Por eso puedes poner una `L` detrás de un número literal para indicar que quieres que sea directamente un `long` en vez de un entero.
* Un número escrito con un punto decimal se entiende que es `double`. Puedes especificar que quieres que sea `float` poniendo una `F` después.


### Mínimos y máximos de tipos primitivos

* `byte`: de `–128` a `127`
* `short`: de `–32768` a `32767`
* `int`: de `–2147483648` a `2147483647`
* `long`: de `–9223372036854775808` a `9223372036854775807`
* `float`: de `1.4e–45` a `3.4028235e38` (y también los mismos valores en negativo)
* `double`: de `4.9e–324` a `1.7976931348623157e308` (y también los mismos valores en negativo)


### Actividad 0019

¿Cuál sería el código para declarar y asignar a la variable local `a` de tipo `float` el valor `45,05`? ¿Cuál sería el código para declarar y asignar a la variable local `b` de tipo `long` el valor `991909000000`? Prueba tus respuestas con el CodePad de BlueJ para comprobar que son correctas.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0019">
Mostrar solucion
</button>
<div id="0019" class="collapse">
Las líneas de código que declaran las variables y asignan los valores indicados son las siguientes:

{% highlight java %}
float a = 45.05F;
long b = 991909000000L;
{% endhighlight %}
</div>


### Actividad 0005

1. Clona el repositorio `clock-display` de mi página de GitHub y ábrelo con BlueJ. 
2. Crea un objeto de la clase `ClockDisplay` usando el constructor sin parámetros.
3. Inspecciona el objeto y con la ventana de inspección abierta, invoca los métodos del objeto. Observa cómo cambia el atributo `displayString` (que es la cadena que pedía tu amigo que devolviera el objeto `ClockDisplay`).

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0005">
Mostrar solucion
</button>
<div id="0005" class="collapse">
[Ver video en Youtube](http://youtu.be/OIrlbefeQ3E)
</div>



### Revisión de la clase NumberDisplay (1). Operadores lógicos

[Ver explicación en Youtube](http://youtu.be/9BcK7nrjYMA)

<!--
La clase cuenta con dos atributos de tipo `int`: el valor actual del display y el límite del display. 

Este límite es pasado como parámetro al construtor de `NumberDisplay`. Si, por ejemplo, se fija a 24, en cuanto el valor actual llega a ese valor automáticamente se le hace volver a 0, ṕor lo que el rango del display es de 0 a 23. El constructor además fija el valor actual del display a 0.

El método getter del atributo `value` es tan simple que no comentaremos nada de él. 

El siguiente método, el setter de `value` es más interesante. Recibe como parámetro el nuevo valor, pero antes de asignarlo comprueba que el nuevo valor es legal, es decir, está en el rango de valores que puede tomar `value`. Usamos un condicional `if` y vemos que nos encontramos en la condición el símbolo `&&`. Este símbolo es un operador lógico de tipo and. Hace que la condición sea cierta si y solo si ambas partes de la condición son ciertas.

los tres opoeradores lógicos más importantes son and, or y not. Operan sobre valores booleanos (es decir, valor true o false) y producen un nuevo valor booleano. En Java se escribe así:

- `&&` es el operador and.
- `||` es el operador or.
- `!` es el operador not.

la expresión `a && b` es cierta si y solo si ambas partes son ciertas. La expresión `a || b` es cierta si una de las dos partes es cierta. Finalmente, la expresión `!a` es cierta si `a` es falso.
-->

### Actividad 0006

Ṕiensa qué sucede cuando el método `setValue` es invocado utilizando un parámetro cuyo valor es ilegal para `value`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0006">
Mostrar solucion
</button>
<div id="0006" class="collapse">
No sucede nada: ni sale un mensaje de error por pantalla ni se fija el valor del atributo.
</div> 


### Actividad 0007

Piensa qué sucedería si reeemplazaramos el operador `>=` en la condición del método `setValue` por `>`, de forma que quedara como:

	if ((replacementValue > 0) && (replacementValue < limit))

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0007">
Mostrar solucion
</button>
<div id="0007" class="collapse">
No se podrían fijar valores iguales a 0 para el atributo `value`.
</div> 


### Actividad 0008

Piensa qué sucedería si reempazaramos el operador `&&` en la condición del método `setValue` por `||` de forma que quedara como:

	ìf ((replacementValue >= 0) || (replacementValue < limit))

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0008">
Mostrar solucion
</button>
<div id="0008" class="collapse">
Se podrían fijar valores superiores al límite e inferiores a 0.
</div> 


### Actividad 0009

Piensa cuál de estas expresiones devuelve `true`:

1. `! (4 < 5)`
2. `! false`
3. `(2 > 2) ││ ((4 == 4) && (1 < 0))`
4. `(2 > 2) ││ (4 == 4) && (1 < 0)`
5. `(34 != 33) && ! false`

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0009">
Mostrar solucion
</button>
<div id="0009" class="collapse">
La segunda y la quinta son las únicas que devuelven `true`.
</div> 


### Actividad 0010

Comprueba en el Code Pad de BlueJ que los resultados que has pensado para la actividad anterior son correctos.


### Actividad 0011

Escribe en tu cuaderno una expresión usando variables booleanas `a` y `b` que devuelva `true` solo cuando una de las dos sea verdadera y `false` en el resto de ocasiones.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0011">
Mostrar solucion
</button>
<div id="0011" class="collapse">
Una posible solución sería `(!a && b) || (a && !b)`, aunque existen muchas más. A esta operación se le denomina _or exclusivo_.
</div> 


### Actividad 0012

Si tenemos en cuenta la expresión `(a && b)`, escribe en tu cuaderno una expresión equivalente sin usar el operador `&&` que devuelva lo mismo que la anterior para todos los casos de `a` y `b`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0012">
Mostrar solucion
</button>
<div id="0012" class="collapse">
Una posible solución sería `!(!a || !b)`, aunque existen otras muchas soluciones distintas.
</div> 


### Revisión de la clase NumberDisplay (II): concatenación de cadenas

[Ver explicación en Youtube](http://youtu.be/67Bq7dhgdFI)

<!--
El siguiente método, `getNumberDisplay`, también devuelve el valor del display, pero en un formato diferente. La razón es que nuestro objetivo es que el reloj muestre tanto las horas como los minutos con dos dígitos. Así, si el tiempo almacenado es 3:05, el display debe devolver "03:05". El método `getNumberDisplay` devuelve el valor almacenado como `String` y añade un 0 si el valor es menor que 10. 

	if(value < 10) {
		return "0" + value;
	}
	else {
		return "" + value;
	}

Date cuenta que el "0" está escrito en comillas dobles. Lo que hemos hecho es escribir la `String` `"0"` en vez de número entero `0`. El operador `+` indica que queremos hacer una concatenación, dado que el primer operando es un `String`.

El símbolo `+` tiene diferentes significados, dependiendo del tipo de operados. Si ambos son números, representa la suma numérica:

	42 + 12

Que produce `54` como resultado. Sin embargo, si los operandos son `String`, entonces el signo `+` indica concatenación y el resultado es una cadena que consiste en los dos operandos puestos uno al lado del otro. Por ejemplo:

	"Java" + "with Bluej"

da como resultado:

	"javawith Bluej"

Date cuenta que Java al concatenar no coloca espacios entre las cadenas. Si queremos un espacio entre medias debemos de añadirlo en alguna de las dos cadenas. Así, por ejemplo:

	"answer: " + 42

da como resultado:

	"answer: 42"

Este modo de funcionamiento es válido para todos los tipos: siempre que concatenamos algo a una cadena, ese algo es convertido automáticamente a `String` y luego concatenado. 

Si volvemos al código de `NumberDisplay`, tenemos que si `value` vale `3`, entonces:

	return "0" + value;

devuelve la cadena "03". 

En nuestro metodo hemos hecho un pequeño truco:

	return "" + value;

En la línea anterior, concatenamos la cadena vacía con `value`. El resultado es que que `value` se convierte en cadena de dos cifras.
-->


### Actividad 0013 

¿Qué sucede si como límite de `NumberDisplay` fijas el valor `800` ?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0013">
Mostrar solucion
</button>
<div id="0013" class="collapse">
El método `getDisplayValue()` deja de funcionar correctamente porque devolvería valores de 3 cifras una vez que el atributo `value` llegara a 99 y se le incrementara una vez más.
</div> 


### Actividad 0014

En el método `getDisplayValue()`, habría alguna diferencia entre usar

	return value + "";

en vez de 

	return "" + value;

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0014">
Mostrar solucion
</button>
<div id="0014" class="collapse">
No habría ninguna diferencia.
</div> 	


### Revisión de la clase NumberDisplay (III): operador módulo

[Ver explicación en Youtube](http://youtu.be/STqnDJgP4bI)

<!--
El último método de la clase `NumberDisplay` incrementa el valor en 1 teniendo en cuenta que cuando llega al limite debe volver a fijarlo a 0.

	public void increment()
	{
		value = (value + 1) % limit;
	}

Este método usa el operador módulo (`%`) que calcula el resto de una división entera. Por ejemplo, la división entera `27 / 4` produce `6` como resultado y `3` como resto. Por tanto, `27 % 4` devuelve `3`.
-->


### Actividad 0015

¿Cuál es el resultado de `8 % 3`? Prueba en el CodePad si tu respuesta es correcta.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0015">
Mostrar solucion
</button>
<div id="0015" class="collapse">
El resultado es `2`.
</div> 	


### Actividad 0016

¿Cuáles son los posibles resultados de `n % 5` si `n` es una variable entera que puede tomar cualquier valor? ¿Cuáles son los posibles resultados de `n % m` si `n` y `m` son variables enteras?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0016">
Mostrar solucion
</button>
<div id="0016" class="collapse">

* En el primer caso, los resultados posibles son `0`, `1`, `2`, `3` y `4`.
* En el segundo caso, los posibles resultados van desde `0` a `m - 1`.

</div> 	


### Actividad 0017

Reescribe en tu cuaderno el método `increment` usando un `if` sin utilizar el operador módulo.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0017">
Mostrar solucion
</button>
<div id="0017" class="collapse">
Una posible solución sería:

{% highlight java %}
public void increment() {
	value = value + 1;
	if (value == limit) {
		value = 0;
	}
}
{% endhighlight %}
</div> 


### Actividad 0018 

Crea un nuevo proyecto en BlueJ y añadele dos clases: la clase `NumberDisplay` y la clase `ClockDisplay`. El código de la clase `NumberDisplay` debe ser el que hemos estudiado hasta ahora, es decir, el que figura en mi repositorio de GitHub; la clase `ClockDisplay` la debes codificar tú a tu manera (sin mirar cómo se ha implementado en el proyecto `clock-display` que has clonado de GitHub). 

En concreto tu clase `ClockDisplay` debe:

1. Tener 2 atributos de tipo `NumberDisplay`, uno para las horas y otro para los minutos.
2. Tener un atributo de tipo `String` donde se almacena la hora actual del reloj con 5 caracteres.
3. Tener 2 constructores: uno sin parámetros, que fija la hora a "00:00" y otro con 2 parámetros de tipo `int`, que representan las horas y los minutos a los que fijar la hora actual.
4. Tener un método `setTime` que acepte dos parámetros de tipo `int`, horas y minutos, y que fije dichos valores como el tiempo actual del reloj.
5. Tener un método `getTime` que devuelva la hora como `String` de 5 caracteres.
6. Tener un método `timeTick` que haga avanzar un minuto la hora actual (sea esta la que sea originalmente).

No te olvides de usar git como sistema de control de versiones y de realizar un commit con cada añadido que le hagas a tu clase.


### Revisión de la clase ClockDisplay

[Ver explicación en Youtube](http://youtu.be/9xnWk7KdWEQ) 

<!--
(Objetos creando objetos, llamadas internas y externas, múltiples constructores y sobrecarga)

La clase cuenta con 3 atributos. Dos de ellos son del tipo `NumberDisplay` y los utilizaremos para representar las horas y los minutos; el tercero, `displayString`, es de tipo `String` y nos va a permitir tener almacenada permanentemente la cadena de 5 caracteres que debemos devolver.

A continuación tenemos el constructor de la clase `ClockDisplay`. Como programadores de la clase `ClockDisplay` nos tenemos que preocupar de que se creen los dos objetos de la clase `NumberDisplay` con los límites adecuados y eso lo hacemos en las dos primeras líneas del constructor.

Recordemos que la sintaxis para crear un objeto y guardarlo en una variable o atributo es:

	ClassName variable;
	variable = new ClassName(parameter-list)

El operador `new` en estas 2 primeras líneas crea en memoria los dos objetos de la clase `NumberDisplay` y ejecuta el constructor de la clase para cada uno de ellos. Este constructor necesita de un parámetro para ejecutarse, cuyo valor se especifica directamente, es decir, como un literal.

Como vemos en este constructor, podemos hacer que los objetos creen otros objetos.

La última línea del constructor es lo que llamamos una invocación de un método. En concreto es una invocación o llamada a un método interno, ya que el constructor está invocando al método `updateDisplay` del mismo objeto desde donde se invoca.

Cuando se encuentra una invocación o llamada a un método interno, se ejecuta este método interno y cuando este termina la ejecución vuelve a la siguiente sentencia después de la llamada.

Si saltamos al método `updateDisplay`, vemos que este método es reponsable de actualizar el valor del atributo `displayString` para que contenga la representación en una `String` de 5 caracteres de la hora almacenada actualmente en el reloj. Por tanto, este método se invoca cada vez que se produce un cambio en la hora almacenada.

	displayString = hours.getDisplayValue() + ":" + minutes.getDisplayValue();

En la línea de código del método `updateDisplay` vemos que se producen dos invocaciones al mismo método sobre dos objetos diferentes: una invocación al método `getDisplayValue` sobre el objeto al que hace referencia el atributo `hours` y otra invocación al mismo método pero sobre el objeto al que hace referencia el objeto `minutes`. Esta es una invocación o llamada a un método externo, ya que es un método de otro objeto.

Es muy importante darse cuenta que para invocar un método de un objeto usamos antes del punto el nombre del atributo o de la variable que hacen referencia al mismo y no el nombre de la clase. Usamos `hours.getDisplayValue()` y no `NumberDisplay.getDisplayValue()`.

Si seguimos examinando la clase `ClockDisplay` nos encontramos con otro constructor. Es común que una clase tenga más de un constructor para realizar distintas inicializaciones. En nuestro ejemplo, el primer constructor inicializa la hora siempre a `"00:00"` mientras que el segundo permite inicializar la hora a la que nosotros queramos. 

No solo está permitido tener varios constructores sino que podemos tener también varios métodos con el mismo nombre. Lo que se exige es que tengan un conjunto de parámetros diferentes, teniendo en cuenta tipo y número de dichos parámetros. 

Esta característica de Java y de muchos lenguajes de programación se conoce como sobrecarga. Si en una clase hay dos métodos con el mismo nombre decimos que ese método esta sobrecargado. Será obligatorio que los métodos cuenten con un conjunto de parámetros diferente lo que permite a Java saber cuando queremos llamar a uno o a otro.

El método `timeTick` hace una llamada al método `incremente` del objeto que representa los minutos y luego hace una llamada al método `getValue` de ese mismo objeto y testea si el valor devuelto es 0, lo que supone que hay que llamar al método `increment` del objeto al que hacer referencia el atributo `hours`. Si el valor devuelto no es igual a 0 no hace nada. Recordad que se pueden tener sentencias `if` sin la parte `else`.

El método `setTime` toma dos parámetros que representan la hora y los minutos y fija en el reloj la hora correspondiente mediante llamadas externas. Al final invoca al método `updateDisplay` para mantener correcto el atributo `displayString`.

Finalmente, el método getter `getTime` es de funcioanmiento trivial.
-->


### Actividad 0020

Imagina que creamos un objeto de la clase `ClockDisplay` a través de su constructor sin parámetros:

1. ¿Cuántas veces tendríamos que invocar con BlueJ el método `timeTick` para que el reloj contuviera la hora `"01:00"`?
2. ¿De qué otras dos formas podríamos hacer que el reloj contuviera esa hora?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0020">
Mostrar solucion
</button>
<div id="0020" class="collapse">

1. Deberíamos invocar el método `timeTick` 60 veces.
2. Dos formas de hacer que el reloj contenga la hora `01:00` son:
	* Crear nuestro objeto reloj con el constructor de `ClockDisplay` con los parámetros adecuados.
	* Crear nuestro objeto reloj con el constructor sin parámetros de `ClockDisplay` y luego invocar el método `setTime` con los parámetros adecuados.

</div> 


### Actividad 0021

Crea con el CodePad un objeto de tipo `NumberDisplay` e invoca también en el CodePad sobre ese objeto los métodos `getValue()`, `setValue(int value)` e `increment()`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0021">
Mostrar solucion
</button>
<div id="0021" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/eMoAUJ9m5HM) 

Fijate como cuando creamos el objeto o usamos un modificador, el CodePad nos exige el punto y coma al final de la línea. Si lo que usamos es un getter, entonces el CodePad nos permite ponerlo o no ese punto y coma: si no lo ponemos el resultado devuelto por el método se muestra en pantalla. Si lo ponemos se ejecuta el método pero no se muestra nada.
</div> 


### Actividad 0022

Escribe en tu cuaderno la firma del constructor de una supuesta clase llamada `Editor` sabiendo que cuando queremos crear objetos de esa clase usamos la siguiente línea:

{% highlight java %}
Editor a = new Editor("readme.txt", –1)
{% endhighlight %}

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0022">
Mostrar solucion
</button>
<div id="0022" class="collapse">
Una posible solución sería:

{% highlight java %}
public Editor(String file, int mode)
{% endhighlight %}
</div> 


### Actividad 0023 

Escribe en tu cuaderno dos líneas de código que definan una variable llamada `window` del tipo `Rectangle` y que creen un objeto `Rectangle` y lo asignen a la variable teniendo en cuenta que el constructor de la clase `Rectangle` requiere dos parámetros de tipo `int`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0023">
Mostrar solucion
</button>
<div id="0023" class="collapse">
Una posible solución sería: 

{% highlight java %}
Rectangle window;
window = new Rectangle(2, 4);
{% endhighlight %}
</div> 

### Actividad 0024

¿Cómo habría que codificar el código del constructor sin parámetros de la clase `ClockDisplay` para que no se invocara al método `updateDisplay` pero el constructor siguiera teniendo la misma funcionalidad?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0024">
Mostrar solucion
</button>
<div id="0024" class="collapse">
Una solućión sería la siguiente: 

{% highlight java %}
public ClockDisplay()
{
	hours = new NumberDisplay(24);
	minutes = new NumberDisplay(60);
	setTime(0, 0);
}
{% endhighlight %}
</div> 


### Actividad 0025 

Imagina que tuvieramos codificada una clase llamada `Printer` y que en el CodePad ejecutase la sentencia `Printer p = new Printer()`. Sabemos que la clase `Printer` contiene dos métodos con las siguientes firmas:

{% highlight java %}
public void print(String filename, boolean doubleSided)
public int getStatus(int delay)
{% endhighlight %}

Escribe en tu cuaderno dos posible formas de llamar a cada uno de esos métodos en el CodePad sobre el objeto `p`.


<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0025">
Mostrar solucion
</button>
<div id="0025" class="collapse">
Dos posibles soluciones serían:

{% highlight java %}
p.print("hola.txt", true);
p.getStatus(24);
{% endhighlight %}

o:

{% highlight java %}
p.print("data.dat", false);
p.getStatus(-50);
{% endhighlight %}
</div> 


### Actividad 0026

Clona el proyecto `clock-display` de mi página de GitHub. Crea un repositorio de git en la carpeta que se ha creado y haz un commit.

A continuación se pide que modifiques el código para que el reloj funcione como un reloj en formato de 12 horas en vez de 24. Ojo porque los relojes en formato de 12 horas despues del mediodía o de la medianoche no muestran, por ejemplo, `00:30` sino `12:30am` o en vez de `12:15` muestran `12:15pm`. Además, la cadena que se debe devolver ya no es de 5 caracteres sino de 7: ejemplo de ella son `"12:45am"` o `"09:55pm"`. Solo puedes modificar el código de la clase `ClockDisplay`. 

Recuerda usar git como sistema de control de versiones. Nombra el último commit como `"Version final actividad 0026"`.


### Actividad 0027

Si se te ocurre otra forma de hacerlo, modifica el código de la actividad 0026 de forma que logres el mismo resultado (un reloj en formato de 12 horas) pero utilizando otra solución distinta.

Recuerda usar git como sistema de control de versiones. Nombra el último commit como `"Version final actividad 0027"`.


### Actividad 0028

Crea un nuevo proyecto clonando el proyecto `clock-display` de mi página de GitHub. Elimina el atributo `displayString` de la clase `ClockDisplay` y consigue que esa clase siga funcionando correctamente como un reloj de 24 horas.


### Funcionamiento simplificado del sistema de email de Internet

[Ver explicación en Youtube](http://youtu.be/2TZxZqEQnTc) 

<!--
La idea del próximo proyecto con el que vamos a trabajar es simular el funcionamiento del correo electrónico. Deberías pausar el vídeo y pensar qué objetos intervienen en el funcionamiento del correo electrónico.
-->


### Clases necesarias para simular el sistema de email de Internet

[Ver explicación en Youtube](http://youtu.be/Yq1AXheoDwQ) 

<!--
Si lo vemos de forma simplificada podemos quedarnos con 3 tipos de objetos:

1. Un tipo de objetos serían los mensajes de correo electrónico.
2. El segundo tipo de objeto son los clientes de correo electrónico, es decir, los programas que nos permiten redactar, enviar y recibir correos tipo Gmail, Yahoo o Outlook.
3. El tercer tipo de objetos serían los servidores de correo, donde se almacenan temporalmente los mensajes que enviamos hasta que el programa cliente del usuario a quien le mandamos el correo lo descarga de dicho servidor.

Así que podemos deducir que hay 3 clases:

1. MailItem, que representa los mensajes de correo.
2. MailClient, que representa los programas clientes de correo electronico.
3. MailServer, que representa los servidores de correo.

Veamos qué funcionalidad debería tener cada clase:

* Con respecto a la clase MailClient:
	* El usuario debe ser capaz de crear mensajes, es decir, objetos MailItem y enviarlos.
	* El usuario debe ser capaz de descargar del servidor, es decir, de un objeto MailServer, el próximo mensaje no descargado, es decir, un objeto MailItem, y que este se muestre en pantalla.	
	* Debemos poder crear tantos objetos de la clase como queramos, cada uno asociado a un nombre de usuario.
* Con respecto a la clase MailServer:
	* Debe ser capaz de manejar el intercambio de mensajes entre los clientes de correo.
* Con respecto a la clase MailItem:
	* Debe permitir crear un mensaje y acceder a sus propiedades (remitente, destinatario y mensaje)

La clase MailServer implica ciertos conceptos avanzados por lo que no la estudiaremos. Vamos a confiar en que está bien programada y que funciona correctamente. Esto es usar abstracción, ya que no nos vamos a preocupar de la complejidad interna del código de la clase y solo vamos a considerar qué se puede hacer con ella.
-->


### Actividad 0029

Vamos a interactuar con un proyecto ya hecho para simular el escenario anterior.

1. Clona de mi página de GitHub el repositorio `mail-system`.
2. Ábrelo con BlueJ a través de la opción "File > Open non BlueJ".
3. Crea un objeto `MailServer` y dale un nombre al objeto.
4. Crea un par de objetos `MailClient` con los nombre de usuario que quieras y como servidor el creado en el punto anterior.
5. Crea, desde el cliente de correo del primer usuario, un mensaje para el segundo usuario y envíalo.
6. En el cliente del segundo usuario, solicita que se descargue el siguiente mensaje sin descargar del servidor y que se muestre en pantalla.
7. Repite el paso anterior.
8. Ahora repite los pasos 5 y 6 pero en sentido contrario.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0029">
Mostrar solucion
</button>
<div id="0029" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/U3mMTjcbojA) 
</div> 


### Actividad 0030

1. Crea un nuevo proyecto llamado `my-mail-system` en BlueJ.
2. Crea 3 clases: `MailItem`, `MailClient` y `MailServer`.
3. Copia el código de la clase `MailServer` que encontrarás en el archivo `MailServer.java` del proyecto `mail-system` de mi página de GitHub en tu clase `MailServer`. Puedes y debes echar un vistazo a los métodos disponibles de esa clase, ya que será necesario que los invoques para poder completar tu trabajo.
4. Codifica por ti mismo las otras dos clases de forma que:
	1. La clase `MailItem`:
		* Disponga 3 atributos de tipo `String` llamados `from`, `to` y `message`.
		* Disponga de un constructor que permita crear un objeto `MailItem` inicializando sus atributos por medio de parámetros.
		* Disponga de 3 métodos getter.
		* Disponga de un método `print` que no tenga parámetros y que muestre por pantalla los atributos del objeto.
	2. La clase `MailClient`:
		* Disponga de 2 atributos: uno de tipo `MailServer` llamado `server` y otro de tipo `String` llamado `user`.
		* Disponga de un constructor que permita crear un objeto `MailClient` inicializando sus atributos por medio de parámetros.
		* Disponga de un método llamado `getNextMailItem` que recupere del servidor un objeto `MailItem` y devuelva dicho objeto.
		* Disponga de un método llamado `printNextMailItem` que recupere del servidor un objeto `MailItem` e imprima por pantalla los datos de dicho mensaje. Si no hay ningun mensaje, que muestre un mensaje por pantalla informando de ello. 
		* Disponga de un método llamado `sendMailItem` que reciba 2 parámetros (un `String` indicando para quién es el mensaje y otro `String` indicando el contenido del mensaje), cree un objeto `MailItem` basándose en la información de dichos parámetros y lo envíe al servidor asociado a ese cliente.

Comprueba que funciona tal y como funcionaba el proyecto descargado en la actividad anterior.

Intenta completar por ti mismo las clases que se piden (`MailClient` y `MailItem`) sin mirar la implementación que figura en el repositorio de GitHub.

Esta actividad tiene un poco de dificultad a la hora de rescribir la clase `MailItem` por lo que no deberías preocuparte si no eres capaz de completarla. En ese caso, mira el código para esa clase que hay en mi repositorio e intenta entenderlo. En cualquier caso, la clase `MailItem` si que debes ser capaz de realizarla tú solo.

Recuerda usar git como sistema de control de versiones.


### Revisión del constructor de la clase MailItem. Palabra reservada this.

[Ver explicación en Youtube](http://youtu.be/JkR4IXaSCc8) 

<!--
Lo más destacable del código del constructor de MailItem es la palabra reservada this.

Usamos this cuando un nombre está sobrecargado, es decir, cuando un mismo nombre es usado por dos entidades diferentes. En este caso, si nos fijamos en los parámetros, tenemos que existen los nombres, from, to y message; si nos fijamos en los 3 atributos de la clase tenemos que usan los mismos nombres. Así que cuando se inicia la ejecución del constructor, tenemos que hay 6 entidades, 3 parámetros y 3 atributos, cuyos nombres se comparten.

Así que si en el constructor usamos la palabra `from`, la pregunta es: ¿a qué nos estamos refiriendo, al parámetro o al atributo? Java define que cuando aparece un nombre sobercargado se usa la entidad cuya definición esté más cerca. En este caso sería el parámetro, ya que su definición está más cerca que la de los atributos. Así que necesitamos un sistema de referirnos al atributo `from` y para ello se usa `this`.

La expresión `this` se refiere al propio objeto. Así, `this.from` se refiere al atributo `from` del objeto en el que estemos.

Así, la línea:

	this.from = from;

Asigna el valor del parámetro from al atributo from del objeto.

La última pregunta sobre esto sería: ¿por qué usar los mismos nombres en los atributos y los parámetros? La razón es que a veces viene bien que sean los mismos por razones de lectura, ya que tal vez haya solo una palabra totalmente adecuada para describir el parámetro o el atributo y así no hay que inventar una segunda palabra. Además, volviendo al tema de la asbtracción, podemos pensar en alquien que use nuestra clase y vea solo los métodos disponibles. Será mucho mejor una línea como esta para describir el uso del constructor:

	public MailItem(String from, String to, String message)

que no una como:

	public MailItem(String f, String t, String m)

para evitar usar atributos y parámetros repetidos.
-->


### Actividad 0031

Modifica el código del proyecto de la actividad 0030 para que los nombre de los parámetros de los constructores de `MailItem` y de `MailClient` coincidan con los nombres de los atributos de dichas clases. Crea un nuevo commit con los cambios.


### Debuggers o depuradores de código

[Ver explicación en Youtube](http://youtu.be/Qg9uFcoaV4I) 

<!--
La técnica más utilizada para analizar programas es leer el código fuente. La habilidad de leer el código fuente y entenderlo es básica para cualquier programador. Sin embargo, a veces es necesario usar otras herramientas para ver detalladamente como se comporta un programa cuando se ejecuta. De entre todas estas, la más importante es el debugger o depurador.

¿Qué es un debugger? Un debugger es un herramienta que nos permite detener la ejecución de un programa en una determinada línea de nuestro programa y ejecutar paso a paso el código fuente a partir de ahí pudiendo observar el valor de todas las variables existentes.

Los debuggers nos permiten localizar bugs de nuestro programa, es decir, los errores que suceden al ejecutarlo.

Todos los IDEs, entornos integrados de desarrollo, poseen su propio debugger y BlueJ también cuenta con uno. Para acceder a él en el menú View > Show debugger

Para empezar nuestra investigación vamos a fijar un breakpoint. Un breakpoint o punto de ruptura es una señal asociada a una línea de código que indica que cuando la ejecución llegue a esa línea esta debe detenerse.

En BlueJ, una vez que una clase está compilada, se puede establecer un breakpoint bien a través del menú Tools > Set/Clear breakpoint o bien pulsando Control+b o bien haciendo clic en el margen izquierdo. Vamos a fijar un breakpoint en la primera línea del método printNextMailItem.

Una vez fijado el breakpoint, vamos a invocar el método printNextMailItem en el primer cliente. La ventana del debugger aparecerá. En esa ventana tenemos varios controles en la parte inferior que nos permiten continurar o interrumpir la ejecución del programa.

En la parte derecha del debugger tenemos 3 areas que muestran el contenido de las variables. La primera, para variables estáticas, vamos a obviarla de momento; el área para las instance variable o atributos contiene dos elementos. Fijate que no hay aun variables locales.

Una vez detenida la ejecución podemos optar por continuar ejecutando el programa paso a paso, línea a línea a través deñ botón Step. Podemos ir viendo como cambian las variables.

Ahora deberías de ser capaz de predecir qué camino seguirá la ejecución. 

Podemos usar el botón de Step repetidamente para ir avanzando línea a línea. Esto es especialmente interesante cuando hay sentencias if, porque así podemos comprobar que el programa avanza opor el camino esperado. 

Otra posibilidad es usar Step into. Este sistema nos permite introducirnos en la ejecución de los métodos que se presentan.
-->


### Usar la función _Step into_ del debugger

[Ver explicación en Youtube](http://youtu.be/tjvz2UxBJzk) 

<!--
De la misma forma que con los métodos, podemos usar la opción _Step into_ del debugger para ver como se ejecuta un método en concreto. Por ejemplo, en el método `sendMailItem` observamos como dicho método crea un objeto de la clase `MailItem` en la primera línea mediante el operador `new`. Este proceso puede ser observado con la opción _Step into_ del debugger si fijamos un breakpoint en esa línea.
-->


### Actividad 0032

1. Clona de mi página de GitHub el proyecto `better-ticket-machine` y ábrelo con BlueJ.
2. Fija un _breakpoint_ en la primera línea del método `insertMoney`.
3. Haz lo necesario para ver en la ejecución paso a paso del debugger como se toma el primer camino del `if`
4. Haz lo necesario para ver en la ejecución paso a paso del debugger como se toma el segundo camino del `if`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0032">
Mostrar solucion
</button>
<div id="0032" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/uyt4bvELBBc) 
</div> 


### Actividad 0033

1. A partir del código de la actividad 0031, añade un atributo `subject` (asunto) a la clase `MailItem`. 
3. Haz las modificaciones necesarias en la clase `MailClient` para poder crear y enviar emails con asunto.
2. Asegúrate que, ahora, cuando se muestran los email por pantalla, se muestre también el asunto del email. 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0033">
Mostrar solucion
</button>
<div id="0033" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/F232HzQjqe0) 
</div> 


### Actividad 0034

Un amigo nuestro nos dice que ha hecho una clase que tiene el siguiente código fuente:

{% highlight java %}
public class Screen
{
	public Screen(int xRes, int yRes)
	{ 
	}
	
	public int numberOfPixels()
	{ 
	}

	public void clear(boolean invert)
	{ 
	}
}
{% endhighlight %}


Nos dice que, para no liarnos, ha preferido borrar en el código que nos ha pasado el código fuente del interior de los métodos y los atributos de la clase, pero nos asegura que la clase está bien programada y que funciona correctamente.

Se pide que escribas en tu cuaderno:

1. Una línea de código que cree un objeto `Screen` con la resolución que tú quieras y al que haga referencia una variable local `a`.
2. Unas líneas de código que invoquen el método `clear` del objeto creado si y solo si el número de pixels de ese objeto es mayor que dos millones. 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0034">
Mostrar solucion
</button>
<div id="0034" class="collapse">
Este es otro ejemplo de abstracción. Podemos usar una clase sin saber cómo está programada internamente. Solo necesitamos lo que nos ha pasado nuestro amigo.

Así, una posible solución al problema sería:

{% highlight java %}
Screen a = new Screen(1024, 768);
if (a.numberOfPixel() > 2000000) {
	a.clear();
}
{% endhighlight %}

</div> 


### Introducción a la liberia de clases estándar de Java

[Ver explicación en Youtube](http://youtu.be/qP7MW41TQKo)

<!--
1. Ya sabemos que la abstracción nos permite simplificar un problema.
2. Identificamos componentes de un problema y nos fijamos en qué deben de hacer, sin preocuparnos de cómo lo hacen.
3. Es la idea de base de la _libreria de clases estándar_ de Java.
4. Es un conjunto de clases que realizan determinadas tareas.
5. Estas clases no son parte del lenguaje Java.
6. Pero como siempre vienen con Java, las utilizamos como si si fueran parte del lenguaje.
7. No nos preocupamos por cómo están codificadas internamente.
8. Sabemos que podemos crear objetos de dichas clases y los métodos que tienen disponibles y con eso nos basta.
9. Nos ahorran mucho tiempo y esfuerzo.
-->


### El concepto abstracto de _coleccion_

[Ver explicación en Youtube](http://youtu.be/E9S90yHBlwA)

<!--
* A partir de ahora vamos a tratar con colecciones de objetos. 
* Esta parte del curso es especialmente importante y complicada.
* No se puede llegar a ser un buen programador sin entender como funcionan y como se usan las colecciones de objetos

* El concepto de colección se aplica a cuando tenemos un conjunto de objetos del mismo tipo.
* Por ejemplo, el conjunto de estudiantes de una universidad sería una colección.
* El conjunto de estudiantes de un instituto sería otra colección.
* El conjunto de pinturas de Picasso que tengo en mi casa sería otra.

* Hay colecciones grandes y pequeñas.
* ¡También hay colecciones vacías!

* Cuando hablamos de una coleccion, existen una serie de operaciones típicas que se pueden llevar a cabo.
* Podemos añadir objetos.
* Podemos quitar objetos.
* Podemos ordenarla siguiendo un cierto criterio.
* Podemos contar el número de objetos que contiene.

* Todos los lenguajes de programación tienen una clase que representa el concepto de colección.
* En Java esa clase se llama `ArrayList`; en Ruby, `Array`.
* Los métodos de la clase `ArrayList` representan las operaciones típicas que podemos hacer con una colección.

* Si queremos tener una colección, tendremos que crear un objeto de la clase `ArrayList`.
* A nuestro objeto de la clase `ArrayList` le iremos luego añadiendo los objetos de la colección.

* Durante el tiempo de ejecución suele ocurrir que el número de objetos de una colección varía.
* No es buena idea usar un número fijo de atributos en una clase para representar una colección.
* Cuando usamos colecciones no solemos saber qué cantidad máxima de objetos van a contener.
* La clase `ArrayList` de Java permite almacenar un conjunto ordenado de objetos de tamaño flexible.

* Ejemplos de colecciones que se pueden encontrar en aplicaciones informaticas son:
	- Los calendarios electrónicos contienen una coleccion de eventos.	
	- Las tiendas online contienen una coleccion de productos.
	- Los centros escolares tienen programas que almacenan una colección de estudiantes.
-->


### Un organizador de archivos MP3s

[Ver explicación en Youtube](http://youtu.be/DAGgBZArISM)

<!--
* Vamos a construir una clase que sea capaz de servirnos como organizador de nuestra colección de MP3s.
* Nos vamos a apoyar en la clase `ArrayList`, disponible en la _liberia de clases estándar_ de Java.
* La clase `ArrayList` es una clase genérica: permite guardar objetos del mismo tipo pero de cualquier tipo.
* Un objeto de la clase `ArrayList` puede contener objetos `Estudiante` y otro objetos `Perro` sin problema.

* En la primera version del organizador, vamos a tratar solo con una colección de nombres de archivos MP3s.
* Usaremos un objeto de la clase `ArrayList` que contendrá objetos `String`.
* Cada objeto `String` contendrá el nombre de un archivo.

* Se debe poder añadir nombres de archivo a nuestra colección.
* No hay límite predeterminado del número de nombres de archivo que se pueden almacenar.
* El organizador debe ser capaz de decirnos el número de nombres de archivo que tenemos.
* Se debe poder consultar el nombre del archivo que ocupa una determinada posición en la colección.
* Se debe poder borrar un determinado nombre de archivo en función de la posición.

* La funcionalidad de esta primera versión es muy poca.
* La ampliaremos en las versiones siguientes.
* Esto se llama hacer un desarrollo iterativo o incremental, es decir, poco a poco.
-->


### Actividad 0035

1. Clona de mi página de GitHub el repositorio `music-organizer-v1` y ábrelo en BlueJ.
2. Crea un objeto de la clase `MusicOrganizer`.
3. A través de la invocación de alguno de sus métodos añade 3 cadenas de texto con los nombres de archivos MP3 imaginarios.
4. Invoca el método que nos permite ssaber cuántos elementos tiene la colección.
5. Usa el método `listFile` para que se muestre por pantalla el nombre de archivo del primer y del tercer elemento.
6. Elimina el primer objeto de la colección. ¿Qué sucede si invocamos el método `listFile(0)`?
7. ¿Qué sucede si creas un nuevo objeto de la clase `MusicOrganizer` e inmediatamente después invocas sobre él el método `removeFile(0)`?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0035">
Mostrar solucion
</button>
<div id="0035" class="collapse">
[Ver video en Youtube](http://youtu.be/u35hIfRjeUw)
</div> 


### Revisión de la clase MusicOrganizer v1

Antes de ver el siguiente vídeo, te recomiendo que eches un vistazo por tu cuenta a la clase `MusicOrganizer` e intentes entender por tu cuenta qué hace cada línea del ćodigo.

[Ver explicación en Youtube](http://youtu.be/-hU1_4LO7Xo)

<!--
* Las liberías de clases hacen muy potentes a los lenguajes de programación orientados a objeto.
* Estas librerias contienen cientos o miles de clases.
* Son clases que están muy probadas y funcionan correctamente.
* Nos ahorran tiempo a los programadores.
***

* Java llama a estas librerias `packages`.
* La primera línea muestra cómo se le dice a Java que queremos usar la clase `ArrayList`.
* Importamos a nuestro proyecto la clase `ArrayList` del package `java.util`.
* Las importaciones deben ir siempre al principio del código.
* Podemos usar una clase importada como si la hubieramos creado nosotros.
***

* Definimos un atributo de la clase `ArrayList`.
* Los objetos `ArrayList` son de propósito general: pueden contener cualquier tipo de objeto.
* Los operadores `<` y `>` indican que tipo de objetos va a tener la colección.
* En este caso, `String`.
* Las clases en las que es necesario indicar un segundo tipo se llaman _clases genericas_.
* Siempre hay una conexión entre el constructor y los atributos.
* Aqui creamos un objeto `MusicOrganizer`.
* En el proyecto `clock-display`, creabamos 2 objetos `NumberDisplay`.
***

* A partir de Java 7 está disponible el _operador diamante_ (`<>`).
* Podríamos haberlo usado en el constructor.
***

* Es una clase simple: solo hay un atributo.
* De todo lo dificil de hacer se encarga el objeto `ArrayList`.
* Ventaja de las librerias de clases: alguien ya ha hecho el trabajo por nosotros.
***

* Diagrama de objetos con 2 y con 3 cadenas almacenadas.
***

* En el código usamos 4 métodos de `ArrayList`: `add`, `size`, `get` y `remove`.
* Usamos `add` en `addFile`.
* Usamos `size` en `getNumberOfFiles`
***

* Los objetos de una colección se numeran empezando por 0.
* La posición de un objeto en una colección se denomina índice.
* El primer objeto tiene índice 0.
* El último objeto de una colección tiene de índice size-1.
* Los métodos que hacen uso de `get` y `remove` aplican lo anterior.
* Ambos métodos comprueban que el índice sea válido.
* Ún índice válido va de 0 a size-1, ambos incluido.
* Si el índice no es válido se dispara un error `IndexOutOfBoundException` y el programa se para.
***

* El método `removeFile` elimina un objeto dado su índice.
* Usa el método `remove` de la clase `ArrayList`.
* Necesita un índice como parámetro.
* Si eliminamos un objeto, se renumeran los objetos restantes.
***

* Los objetos `ArrayList` pueden contener tantos objetos como necesitemos.
* La abstracción hace que no sea importante saber cómo lo consiguen.
***

* Los objetos `ArrayList` son capaces de devolver cuantos objetos están almacenando ahora mismo.
* Es innecesario usar un atributo más para llevar esta cuenta.
* Duplicar información es siempre una mala idea.
***

* Los objetos `ArrayList` mantienen a los objetos siguiendo un orden.
-->


### Actividad 0036

1. Escribe en tu cuaderno la declaración de un atributo privado llamado `library` que sea de tipo `ArrayList` y pueda contener objetos de la clase `Book`.
2. Escribe en tu cuaderno como inicializarías el atributo del punto anterior.
3. Escribe en tu cuaderno la declaración de una variable local llamada `course` que pueda contener una colección de objetos `Student`.
4. Escribe en tu cuaderno como inicializarías la variable local del punto anterior.
5. Escribe en tu cuaderno la declaración de un atributo privado llamado `tracks` que pueda contener una colección de objetos de la clase `MusicTrack`.
6. Escribe en tu cuaderno como inicializarías el atributo del punto anterior usando el operador diamante.


<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0036">
Mostrar solucion
</button>
<div id="0036" class="collapse">
La solución de los puntos 1 y 2 sería:

{% highlight java %}
private ArrayList<Book> library;
library = new ArrayList<Book>();
{% endhighlight %}

La solución para los puntos 3 y 4 sería:

{% highlight java %}
ArrayList<Student> course;
course = new ArrayList<Student>();
{% endhighlight %}

Finalmente, la solución para los puntos 5 y 6:

{% highlight java %}
private ArrayList<MusicTrack> tracks;
tracks = new ArrayList<>();
{% endhighlight %}

</div> 


### Actividad 0037

1. Si una colección tiene 10 objetos, ¿qué valor devuelve una llamada al método `size()` de dicha colección?
2. Escribe en tu cuaderno una línea de código que invoque el método `get` con el finde que se devuelva el quinto objeto de una colección llamada `items`. 
3. ¿Cuál es el índice del último objeto de una colección que contiene ahora mismo 15 objetos?
4. Escribe en tu cuaderno una línea de código que añada el objeto referenciado en la variable `oldCar` a la colección `myCars`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0037">
Mostrar solucion
</button>
<div id="0037" class="collapse">

1. El método `size` devuelve 10.
2. La línea sería `items.get(4);`.
3. El índice sería el 14.
4. La linea sería `myCars.add(oldCar)`.

</div> 


### Actividad 0038

1. Escribe en tu cuaderno una línea de código que borre el objeto que ocupa la tercera posición de una colección llamada `dates`.
2. Imagina un objeto almacenado en el ídice 6 de una colección. Si eliminamos el objeto que está en el índice número 9 y después el que está en el índice 0, ¿que índice tendrá ahora el objeto?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0038">
Mostrar solucion
</button>
<div id="0038" class="collapse">

1. La línea sería `dates.remove(2);`.
2. El índice actual sería el 5.

</div> 


### Actividad 0039

1. Clona el repositorio `music-organizer-v1` de mi página de GitHub en un directorio llamado `0039`.
2. ¿Cuántos commits tiene el repositorio de tu carpeta `0039` ahora mismo?
3. Añade un método llamado `checkIndex` a la clase `MusicOrganizer`. Toma un parámetro entero y comprueba que sea un índice válido para el atributo `files`. Si el parámetro no es válido debe mostrar un mensaje de error por pantalla e indicar el rango válido. Si el parámetro es válido, no debe mostrar nada.
4. Testea el método añadido creando un objeto de la clase `MusicOrganizer`.
5. En el momento en que hayas testeado que funciona siempre correctamente, haz un commit llamado "_Añadido método checkIndex para comprobar si un índice es válido_".
6. Añade un método llamado `validIndex` que devuelva un valor booleano en función de si su parámetro entero es un índice válido o no para el atributo `files`. Este método no muestra nada por pantalla en ningún caso.
7. Testea el método añadido creando un objeto de la clase `MusicOrganizer`.
8. En el momento en que hayas testeado que funciona siempre correctamente, haz un commit llamado "_Añadido método validIndex para comprobar si un índice es válido_".
9. Reescribe los métodos `listFile` y `removeFile` de la clase `MusicOrganizer` para que usen el método `validIndex` en vez de la condición booleana actual.
10. Testea los cambios creando un objeto de la clase `MusicOrganizer`. 
11. En el momento en que hayas testeado que funciona siempre correctamente, haz un commit llamado "_Métodos listFile y removeFile reescritos para evitar redundancia_".


### Actividad 0040

1. Clona de mi página de Github el repositorio `music-organizer-v2`.
2. Ábrelo en BlueJ.
3. Crea un objeto `MusicOrganizer`.
4. Añade al organizador varios archivos MP3. Si quieres usar MP3 propios, guárdalos en la carpeta `audio`. Si no, en la carpeta `audio` hay 4 archivos de muestra que puedes emplear. En cualquier caso debes añadir al nombre del archivo el prefijo `"audio/"` cuando añadas los archivos al organizador. Por ejemplo, si el archivo se llama `a.mp3`, lo que debes indicar en el organizador es `"audio/a.mp3"`. 
5. Experimenta con el organizador para ver si eres capaz de hacer empezar y detener la reproducción de los archivos MP3 añadidos.
6. Intenta añadir un archivo que no exista en el disco duro. ¿Qué sucede al añadirlo al organizador? ¿Qué sucede cuando queremos reproducirlo?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0040">
Mostrar solucion
</button>
<div id="0040" class="collapse">
[Ver video en Youtube](http://youtu.be/MEZNpjs515c)
</div> 


### Revisión de music-organizer-v2

[Ver explicación en Youtube](http://youtu.be/2f5VJzHCa2s)

<!--
<span class="label label-default">librerias de terceros</span>
* Queremos que nuestro organizador sea capaz en la versión 2 de reproducir los MP3s.
* Pero no tenemos ni idea de cómo conseguirlo.
* Nos aprovechamos de la abstracción.
* Buscamos una clase ya hecha que sea capaz de reproducir MP3s 
* Java no tiene en la liberia de clases estandar una clase así.
***

* Muchos programadores hacen clases y las liberan.
* Se llaman bibliotecas de clases de terceros (_third-party libraries_)
* Se usan como si fueran clases que hemos hecho nosotros.
***

* Echaremos un vistazo al proyecto.
***

* Clase `MusicPlayer`.
* Usamos un clase `MusicPlayer` encontrada en Internet.
* Los objetos `MusicPlayer` son capaces de de:
* Reproducir los primeros segundos de un MP3: método `playSample()`.
* Reproducir música en segundo plano: método `startPlaying()`.
* Parar la música en segundo plano: método `stop()`.
* `playSample` y `startPlaying` requieren de 1 parámetro: el nombre del archivo.
* `startPlaying` comienza a reproducir en segundo plano y retorna.
* `stop` es necesario para parar la música en segundo plano.
* `playSample` reproduce unos segundos y luego retorna.
***

* Clase `MusicOrganizer`.
* Añadido un atributo `MusicPlayer`.
* Añadido en el constructor la inicialización de ese atributo.
* Dos métodos nuevos: `startPlayingFile` y `stopPlaying`.
* Invocan métodos del atributo `MusicPlayer`.
***

* Version creada con muy poco esfuerzo.
* Usamos la funcionalidad de `ArrayLis` y `MusicPlayer`.
* Una es una clase de la librería estandar; la otra es una clase de terceros.
* No nos hemos fijado en el código de ambas.
* Nos fijamos en:
* El nombre de la clase.
* Qué métodos tiene disponibles.
* Qué parámetros llevan.
* Qué valores devuelven.
***
-->


### Actividad 0041

1. Dentro de la clase `MusicOrganizer` del proyecto `music-organizer-v2`, ¿cómo sería la cabecera de un método llamado `listAllFles` cuya labor fuera imprimir por pantall todos los nombres de archivos MP3s almacenados en el organizador en un momento dado? ¿Necesita parámetros?

2. ¿Podríamos escribir como cuerpo de ese método las siguientes 3 líneas? ¿Qué problema le ves?

	``` 
	System.out.println(files.get(0));
	System.out.println(files.get(1));
	System.out.println(files.get(2));
	``` 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0041">
Mostrar solucion
</button>
<div id="0041" class="collapse">
[Ver video en Youtube](http://youtu.be/1DiQvWnFNS8)
</div> 


### Procesando colecciones enteras

[Ver explicación en Youtube](http://youtu.be/4qp17SaIDzI)

<!--
* Muchas veces necesitamos mirar todos los elementos de una colección.
* Necesitamos instrucciones repetitivas, bucles, sentencias iterativas, loop statements...
***

* Bucle `for-each`
* Permite realizar un conjunto de operaciones por cada elemento de una colección.
* Sintaxis:
	
	for (ElementType element : collection) {
		cuerpo del for
	}

* Palabra reservada `for`.
* En Java hay 2 tipos de `for`: el `for` tradicional y el `for-each`
***

* En el `for-each` hay 2 elementos: cabecera y cuerpo
* La cabecera es la primera línea.
* El cuerpo contiene las operaciones a realizar por cada elemento.
* Puede haber tantas líneas de código como se quiera el en cuerpo del `for`.
***

* Podríamos traducir la sintaxis del `for-each` así:

	for each element in collection do {
		cuerpo del for
	}

* Para cada elemento en la coleccion hacer lo que diga el cuerpo del `for`.
***

* Implementemos el método `listAllFiles`:

	public void listAllFiles()
	{
		for(String filename : files) {
			System.out.println(filename);
		}
	}

* La variable `filename` toma el valor de un elemento de la colección.
* Esto se produce antes de que se ejecute el cuerpo del `for`.
* Llamamos a esa variable la _variable del bucle_.
* Podemos usar cualquier nombre para la variable del bucle.
* La variable del bucle tiene que ser del tipo de objetos que hay en la colección.
***

* Despues de `:` se indica la coleccion.
***

* El cuerpo del `for`solo tiene aqui una línea.
* El cuerpo se ejecuta tantas veces como elementos haya.
* Dentro del cuerpo del `for` podemos hacer referencia a la variable del bucle.
***
-->


### Actividad 0042

1. Clona de mi página de Github el repositorio `musi-organizer-v2` en una carpeta llamada `0042`.

2. Abre con BlueJ dicho proyecto.

3. Implementa el método `listAllFiles`.

4. Crea un objeto `MusicOrganizer`y almacena en él unos cuantos nombres de archivos. Testea el método creado en el punto anterior para comprobar que funciona correctamente.

5. Haz un commit con el mensaje "_Añadido método listAllFiles para mostrar todos los archivos MP3s almacenados_".

6. Usa el debugger para entender como funciona el bucle `for-each` del método `listAllFiles`. Para ello fija un breakpoint justo antes del bucle y utiliza la función "_Step_" para ver como se va procesando el bucle.

7. Modifica el método `listAllFiles` para que por cada canción salga la posición que ocupa. Por ejemplo, si hubiera dos canciones, debería aparecer:
	
	```
	1. Shakira - Loba.mp3
	2. Cafe Quijano - Brasil.mp3
	```

8. Testea que funciona correctamente tu modificación y haz un commit con el mensaje "_Ahora se muestra la posición de cada canción en el método listAllFiles_"

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0042_1">
Mostrar pista
</button>
<div id="0042_1" class="collapse">
Una variable local entera es necesaria para la resolución del punto 7.
</div> 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0042">
Mostrar solucion
</button>
<div id="0042" class="collapse">
[Ver video en Youtube](http://youtu.be/F66-2ZQrSFs)
</div> 


### Actividad 0043

1. Crea un objeto de tipo `ArrayList` de `Strings`en el CodePad de BlueJ llamado `miColeccion`.
2. Escribe en el CodePad `miColeccion` y pulsa Enter para que el CodePad muestre el objeto.
3. Arrastra la señal roja del lateral derecho del CodePad al banco de objetos.
4. Examina desde el banco de objetos los métodos deñ objeto e invoca algunos como `add`, `remove`, `size` o `isEmpty`.
5. Invoca esos mismos métodos desde el CodePad.

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0043_1">
Mostrar pista
</button>
<div id="0043_1" class="collapse">
Si no eres capaz de completar el paso número 1, recuerda que `ArrayList` no es una clase de Java sino de la libería estandar y que hay que importarla.
</div> 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0043">
Mostrar solucion
</button>
<div id="0043" class="collapse">
[Ver video en Youtube](http://youtu.be/CbxToQ7yeIU)
</div> 


### Ejecución selectiva de operaciones por cada elemento de una colección

[Ver explicación en Youtube](http://youtu.be/Zt_0-4xXMZs)

<!--
* A veces, queremos hacer algo solo para determinados elementos de una coleccion.
* Por ejemplo, listar los archivos MP3 pero solo de un artista.
* Por ejemplo, listar los archivos MP3 pero cuyo título coin cida con algo.
* Usamos un `if` dentro del cuerpo del `for`.
***

* Implementemos el método `listMatching`
* Muestra solo archivos cuyo nombre contenga una determinada cadena.

	public void listMatching(String searchString)
	{
		for(String filename : files) {
			if(filename.contains(searchString)) {			
				System.out.println(filename);
			}
		}
	}

* El método `contains` devuelve un valor booleano.
-->


### Actividad 0044

1. A partir del código terminado de la actividad 0042, añade el método `listMatching`.
2. Testea que funciona correctamente. ¿Se comportan bien cuando la cadena introducida no se encuentra en ningún archivo?
3. Haz un commit con el mensaje "_Método listMatching añadido para listar solo determinador archivos que contengan una cadena_".
4. Modifica el método `listMatching` para imprimir un mensaje de error en caso de que la cadena introducida no se encuentre en ninguno de los nombres de archivo almacenados.
5. Testea el último cambio y añade un commit con el mensaje "_Añadido mensaje de error ante una busqueda vacia en listMatching_".
6. Escribe un método que reproduzca los primeros segundos de todas las canciones de un determinado artista pasado como parámetro. Para ello vale con que mires si ese nombre de artista está contenido en el nombre de archivo.
7. Testea el método anterior (comprueba situaciones en las que no hay ningun archivo del artista en concreto, en las que hay uno y en las que hay más de uno) y cuando estés seguro de que funciona bien haz un commit con un mensaje descriptivo.
8. Piensa en qué situación se reproduce un archivo con tu método que no es del artista indicado como parámetro.

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0044_1">
Mostrar pista
</button>
<div id="0044_1" class="collapse">

* En el punto 4, debes ayudarte de una variable local booleana.
* En el punto 6, debes utilizar el método `playSample` de la clase `MusicPlayer`.

</div> 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0044">
Mostrar solucion
</button>
<div id="0044" class="collapse">
[Ver video en Youtube](http://youtu.be/oOSgF-W_zR0)
</div> 


### Actividad 0045

1. Escribe únicamente la cabecera de un bucle `for-each` que procese un `ArrayList<Track>` llamado `tracks`.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0045">
Mostrar solucion
</button>
<div id="0045" class="collapse">
La solución es:

{% highlight java %}
for (Track track : tracks) { }
{% endhighlight %}
</div> 


### Actividad 0046

1. Crea un nuevo proyecto en BlueJ llamado `family-tree`.
2. Crea un repositorio git en la carpeta de dicho proyecto.
2. Crea una clase llamada `Person`.
3. Añade a la clase `Person` dos atributos: `name` de tipo `String` y `age` de tipo entero.
4. Implementa un constructor para la clase `Person` que fije el nombre y la edad pasándolos como parámetros.
5. Implementa los siguientes métodos añadiendo 3 atributos a la clase `Person` (`father`, `mother` y `children`):
	1. Método `showData`: muestra por pantalla el nombre y la edad de la persona. No devuelve nada.
	2. Métodos `setMother` y `setFather` que permiten fijar el padre y la madre de una persona. Reciben como parámetro un objeto de tipo `Person` y no devuelven nada.
	3. Métodos `addChild` que permite añadir un hijo a una persona. Reciben como parámetro un objeto `Person` y no devuelven nada.
	4. Método `showParentsData` que muestra por pantalla los datos del padre y la madre de una persona. No devuelve nada.
	5. Método `showChildrenData` que muestra por pantalla los datos de los hijos de una persona. No devuelve nada.
	6. Método `hasChildens` que no muestra nada por pantalla y devuelve ùn valor booleando indicando si una persona tiene hijos o no.
	6. Método `getNumberOfChildren` que no muestra nada por pantalla y devuelve un entero conteniendo el número de hijos de una persona.
	6. Método `hasBrothers` que no muestra nada por pantalla pero devuelve un valor booleano indicando si una persona tiene hermanos o no.
6. Testea el funcionamiento de cada método y vete haciendo commits conforme los vayas implementando.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0046">
Mostrar solucion
</button>
<div id="0046" class="collapse">
[Ver video en Youtube](http://youtu.be/B2_veSYTTMs)

También teneis disponible el código fuente de la solución en mi página web de GitHub (repositorio `family-tree`).
</div> 


### Numero de iteraciones definidas y no definidas

[Ver explicación en Youtube](http://youtu.be/utBtSvByQRU)

<!--
* Bucle for-each: se repite tantas veces como elementos haya en la colección
* Iteración: cada ejecución del cuerpo del for
* Iteración definida: si tenemos una colección, con for-each sabemos cuántas iteraciones habrá
***

* Ejemplo del mundo real de número de iteraciones no definidas
* Llamas a tu madre para que te busque las llaves.
* Hay muchos lugares donde mirar
* Cuando encuentre las llaves dejará de buscar
* No sabemos en cuantos lugares mirará nuestra madre
***

* Iteracion no definidas: se realiza una acción un número de veces hasta que se completa una tarea
* Muy comun en programación
* Todos los lenguajes de programacion tienen una construcción para ella
* En Java, una de ellas es el bucle while
-->


### El bucle while

[Ver explicación en Youtube](http://youtu.be/SqQQ7ichrRU)

<!--
* Sintaxis:

	```
	while (condicion booleana) {
		cuerpo del while
	}
	```

* Palabra reservada while
* Dos partes: condicion booleana y cuerpo del while
***

* La condición
* Se evalua al llegar al while: si es cierta se ejecuta el cuerpo
* Cada vez que se termina de ejecutar el cuerpo se vuelve a evaluar
* Si la condición es falsa se salta a después del while
***

* El cuerpo
* Puede ser ejecutado 0 o más veces o incluso infinitas veces
* Si la condicion es falsa de inicio no se ejecuta
***

* El problema de las llaves con un bucle while:

	```
	while (las llaves estén perdidas) {
		mirar en el siguiente lugar
	}
	```

* También podría expresarse:

	```
	while (not (las llaves han sido encontradas)) {
		mirar en el siguiente lugar
	}
	```

* Ambas son válidas
* En ambos casos, al final del cuerpo hay que conseguir que la condicion sea falsa
-->


### Actividad 0047

Suponiendo que una versión en pseudocódigo  de la busqueda de las llaves fuera:

```
boolean missing = true;
while (missing) {
	if (las llaves están en el siguiente lugar) {
		missing = false;
	}
}
```
Escribe en tu cuaderno una versión completando las partes marcadas con 3 puntos:

```
boolean found = false;
while (...) {
	if (las llaves están en el siguiente lugar) {
		...
	}
}
```

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0047">
Mostrar solucion
</button>
<div id="0047" class="collapse">
La solución es:

```
boolean found = false;
while (!found) {
	if (las llaves están en el siguiente lugar) {
		found = true;
	}
}
```
</div> 


### Bucle while VS Bucle for-each

[Ver explicación en Youtube](http://youtu.be/sxOYLbtorkQ)

<!--
* Código del método listAllFiles con while:

	```
	public void listAllFiles()
	{
		int index = 0;
		while (index < files.size()) {
			String filename = files.get(index);
			System.out.println(filename);
			index++;
		}
	}
	```

* Requiere más esfuerzo que con for-each
***

* Tenemos que declarar una variable para usarla como indice en la coleccion
* Tenemos que inicializar esa variable a 0
* La variable indice debe ser declarada fuera del while
***

* Tenemos que pensar como escribir la condicion 
* El numero de iteraciones debe ser justo el numero de elementos 
***

* Tenemos que declarar una variable local para guardar cada elemento
* Tenemos que asignar el valor de cada elemento a la variable a mano usando get
***

* La variable índice se incrementa al final del bucle
* index++ es equivalente a index = index + 1
* Tipico error: olvidarse e incrementar la variable indice
* Entonces el bucle no termina nunca
* El programa se cuelga
* En BlueJ, la barra no deja de marcar que hace algo
* Por eso un for-each en esta situación es mas seguro
***

* Beneficios del while sobre for-each
* Uno: no se necesita una coleccion para usar while
* Dos: no hace falta procesar todos los elementos
* Podemos parar el bucle en cualquier momento
***

* Beneficios de while con la variable indice
* Podemos usarla en el cuerpo del while
* Por ejemplo, paras sacar por pantalla la posición 

	```
	public void listAllFiles()
	{
		int index = 0;
		while (index < files.size()) {
			String filename = files.get(index);
			System.out.println(index + ": " + filename);
			index++;
		}
	}
	```
-->


### Bucle while: buscando en colecciones

[Ver explicación en Youtube](http://youtu.be/ArJnwcLW-vk)

<!--
* Es muy comun usar un bucle para buscar un elemento en una coleccion
* Las busquedas son un ejemplo de un bucle con un número de iteraciones no definidas
* For-each no es adecuado para busquedas: pierde el tiempo
***

* Vamos a construir un método findFirst
* Busca el primer archivo que contiene una cadena
* Recibe como parametro un String llamado searchString
* Si hay exito en la busqueda retorna el indice del archivo buscado 
* Si no hay exito, retorna -1
* Muy comun este funcionamiento de devolver -1
***

* En una busqueda hay dos situaciones
* No encontramos el elemento despues de mirar en todos los elementos
* Encontramos el elemento a buscar tras un numero de iteraciones
* Ambas circunstancias deben ser tenidas en cuenta en la condicion
***

* Si el elemento a buscar no existe:
* El numero de iteraciones debe ser el numero de elementos: no más
* La variable índice debe tener un valor válido
* Debe ser inferior al numero de elementos

	```
	while (index < files.size())
	```

***

* Si el elemento a buscar existe:
* Podemos usar una variable llamada searching
* Empieza en true y cambia false si encontramos el elemento

	```
	int index = 0;
	boolean searching = true;
	while (index < files.size() && searching)
	```

***

* La solucion final sería:

```
public int findFirst(String searchString)
{
	int index = 0;
	boolean searching = true;
	while(searching && index < files.size()) {
		String filename = files.get(index);
		if(filename.contains(searchString)) {
			searching = false;
		}	
		else {
			index++;
		}
	}
	
	if(searching) {
		return -1;
	}
	else {
		return index;
	}
}
```
-->


### Actividad 0048

1. A partir del código terminado de la actividad 0044, añade el método `findFirst`. Este método debe recibir una cadena como parámetro y devolver el índice del primer archivo que contiene dicha cadena o el valor `-1` en caso de que no se encuentre ningún archivo que cumpla la condición. Debe usar un bucle `while` y la condición debe ser exactamente:

	```
	while (!found && index < files.size())
	```


2. Testea que funciona correctamente. 

3. Haz un commit con el mensaje "_Método findFirst añadido para buscar el primer archivo que contenga una cadena determinada_".

4. Modifica el método para que en cualquier caso que se invoque solo se ejecuta una llamada al método `size` del atributo `files`. 

5. Testea que funciona correctamente. 

3. Haz un commit con el mensaje "_Mejorada la velocidad de ejecución del metodo findFirst_".



### Bucle while: uso sin colecciones

[Ver explicación en Youtube](http://youtu.be/115f9VCP2YQ)

<!--
* Para usar un bucle no es obligatorio una coleccion
* Un ejemplo de un bucle que saca por pantalla los numeros pares que hay del 0 al 30:

```
int index = 0;
while(index <= 30) {
	System.out.println(index);
	index = index + 2;
}
```
-->

### Actividad 0049

1. Crea un nuevo proyecto en BlueJ.
2. Crea una clase llamada `Test`.
3. Implementa un método llamado `multiplesOfFive` que imprima todos los múltiplos de 5 entre 10 y 95 (ambos extremos no incluidos).
4. Implementa un método llamado `sumValues` que saque por pantalla la suma de los números comprendidos entre el 0 y el 10 (ambos incluidos) haciendo uso de un bucle `while`.
5. Implementa un método llamado `sumValuesInterval` que reciba dos parámetros enteros `a` y `b` y muestre la suma de los valores comprendidos entre dichos parámetros (ambos incluidos).
6. Implementa un método llamado `isPrime(int n)` que devuelva verdadero si el parámetro `n` es primo o falso en caso contrario. Debes usar un bucle while  que divida el número entre todos los valores comprendidos entre `2` y `(n -1)`. Si alguna de estas divisiones da de resto 0, entonces el número no es primo.


### Actividad 0050

1. Crea un nuevo projecto en BlueJ.
2. Crea una clase llamada `Test0050`.
3. Implementa 4 métodos para realizar: multiplicaciones enteras, divisiones enteras, módulos, potencias enteras. Debes decididir qué parámetros deben recibir. Todos estos meodos devuelven un valor de tipo entero. Estos métodos no deben mostrar nada por pantalla. Se pone como condición que para realizarlos solo se pueden emplear las operaciones matemáticas suma y resta, no estando permitido usar ninguna otra operación matemática (excepto tus propios métodos).
4. Implementa un método para hacer raices cuadradas enteras. Si el valor pasado como parámetro tiene una raiz cuadrada entera, el método debe devolver este valor (por ejemplo, si el parámetro vale 25, el método debe devolver 5). En caso de que la raíz cuadrada no sea exacta (por ejemplo, de 26), el método debe devolver -1 y sacar un mensaje de error por pantalla. Para hacer este método solo se pueden emplear las operaciones matemáticas suma y resta, no estando permitido usar ninguna otra operación matemática (excepto tus propios métodos). El método debe admitir únicamente parámetros hasta el valor 1000.


### Actividad 0051

1. Clona de mi página de GitHub el repositorio llamado `music-organizer-v5` en una carpeta llamada `0051`.
2. Asegúrate que al clonarlo dispones ya de un repositorio de git para dicho proyecto.
2. Ábre el proyecto con BlueJ.
3. Crea un objeto de la clase `MusicOrganizer`. ¿Qué sucede ahora que no pasaba en versiones anteriores?
4. Investiga qué método invocar sobre el objeto recién creado para listar todos los archivos que contiene el organizador.
5. Investiga qué método invocar sobre el objeto recién creado para listar solo las canciones del artista "Jefferson".

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0051">
Mostrar solucion
</button>
<div id="0051" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/KwA1BEYl2f8)
</div> 


### Revisión del proyecto music-organizer-v5

[Ver explicación en Youtube](http://youtu.be/ftRhTXVzWIU)

<!--
* Usar String para almacenar la informacion de las canciones tiene problemas
* Por ejemplo: Busquedas por nombre de artista o por nombre de canción con resultados erroneos
***

* Un organizador de música comercial permite buscar por varios campos
* Nombre del artista o grupo, título de la canción, álbum, genero, etc.
***

* Con POO podemos crear clases cuya estructura y comportamiento sea casi exacta a la entidad del mundo real
* En este caso, la entidad del mundo real es una canción.
* Clase `Track`: representa una canción del mundo real.
* Guarda cada información de la canción en un atributo.
* Simplificamos: de momento solo guarda artista, titulo de la canción y archivo MP3 asociado
***

* ¿Cómo meter los datos al organizador?
* Una opcion es que el usuario vaya creando objetos Track a pedal
* Debe proporcionar toda la información
* Otra opcion: la clase `TrackReader`
* Tiene un método `readTracks` que toma dos argumentos: carpeta y extensión de los archivos.
* Suponemos que los archivos tienen la estructura "Artista - Titulo.mp3"
* Lee todos los archivos del directorio que le indiquemos y construye un ArrayList de objetos `Tracks`
* Con ese ArrayList ya somos capaces de meterlo todos del tirón
* Abstraccion: no nos preocupamos de cómo está codificada la clase `TrackReader` 
***

* Clase `MusicOrganizer`
***

* Tenemos un atributo `tracks` en vez de `files`
* Ahora almacenamos un ArrayList de objetos Track, no de objetos String
* Esto afecta a muchos métodos, que tienen que ser modificados
* Por ejemplo, el método `playTrack`
* Necesitamos en este método conseguir primero el nombre del archivo
***

* El constructor inicializa los atributos
* Manda leer todos los mp3 de una determinada carpeta
***

* Métodos `listTrack` o `listAllTracks`:
* Se invoca sobre cada objeto `Track` el método `getDetails`.
* Este devuelve los detalles de cada track convenientemente formateados.
* Es un ejemplo de responsability-driven design.
***

* El proyecto es más complicado que antes
* Pero soluciona nuestro problema con las búsquedas
-->


### Actividad 0052

1. A partir del proyecto de la actividad 0051, añade un método llamado `findInTitle` que tome un único parámetro de tipo `String` y muestre por pantalla la información de los tracks que contienen dicha cadena en el título de la canción.
2. Testea los cambios y luego haz un commit.
3. Añade un atributo a la clase `Track` llamado `playCount`. El objetivo de este atributo es llevar la cuenta de las veces que se ha reproducido una canción. Asegúrate de que se fija a 0 en el constructor de la clase `Track`.
4. Añade 2 métodos a la clase `Track`: uno para resetar el contador de reproducciones de un track a 0 y otro para incrementarlo de uno en uno. 
5. Implementa la funcionalidad de que cada vez que se reproduce una canción desde el organizador de música se incremente el contador de reproducciones de esa canción.
6. Testea los cambios y luego haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0052">
Mostrar solucion
</button>
<div id="0052" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/0QkvwhnOeuk)

Ṕuedes consultar el código fuente solución de esta actividad en el repositorio `0051` de mi página de GitHub. Ten cuidado porque también se encuentran disponibles las soluciones en dicho repositorio de las siguientes actividades.
</div> 


### Actividad 0053

1. A partir del proyecto de la actividad 0052, añáde un atributo a tu elección en la clase `Track` y provee a dicha clase de un método getter y un modificador para dicho atributo. 
3. Incluye la información de dicho atributo para que forme parte de la cadena devuelta dentro del método `getDetails`.
4. Añade un método en la clase `MusicOrganizer` para poder fijar el valor de ese nuevo atributo a un determinado track del organizador.
2. Testea los cambios y luego haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0053">
Mostrar solucion
</button>
<div id="0053" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/MMwwbMCZBKg)

Ṕuedes consultar el código fuente solución de esta actividad en el repositorio `0051` de mi página de GitHub. Ten cuidado porque también se encuentran disponibles las soluciones en dicho repositorio de las siguientes actividades.
</div> 


### Actividad 0054

1. A partir del proyecto de la actividad 0053, añade todo lo que consideres necesario para que exista un método llamado `isPlaying` que cuando sea invocado informe por pantalla de si en este momento se está reproduciendo música o no.
2. Testea los cambios y luego haz un commit.
3. Modifica la clase `MusicOrganizer` para que, en el caso de que se este reproduciendo algo en este momento y deseemos reproducir un nuevo track, se muestre un mensaje de error por pantalla informando de que ya hay una reproducción en curso (hasta ahora ambas canciones sonarían a la vez).
4. Testea los cambios y luego haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0054">
Mostrar solucion
</button>
<div id="0054" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/aSh9d8UDQQs)

Ṕuedes consultar el código fuente solución de esta actividad en el repositorio `0051` de mi página de GitHub. Ten cuidado porque también se encuentran disponibles las soluciones en dicho repositorio de las siguientes actividades.
</div> 


### Iteradores

[Ver explicación en Youtube](http://youtu.be/Qsa4CMR9SQI)


### Actividad 0055

1. A partir del proyecto de la actividad 0054, implementa un método llamado `listAllTrackWithIterator` que muestre los detalles de todos los tracks almacenados en un organizador usando un iterador.
2. Testea el método y haz un commit.
3. Implementa un método `removeByArtist` que permita eliminar del organizador tracks que contengan un determinado artista usando un iterador.
4. Testea que funciona correctamente y haz commit de los cambios.
5. Implementa un método `removeByTitle` que permita eliminar del organizador tracks que contengan una determinada cadena en el título de la canción usando un iterador.
6. Testea que funciona correctamente y haz commit de los cambios.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0055">
Mostrar solucion
</button>
<div id="0055" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/dXiexU9SBRE)

Ṕuedes consultar el código fuente solución de esta actividad en el repositorio `0051` de mi página de GitHub. Ten cuidado porque también se encuentran disponibles las soluciones en dicho repositorio de las siguientes actividades.
</div> 


### Actividad 0056

1. Clona el repositorio `club` en la carpeta `0056` de tu ordenador.
2. El objetivo de este proyecto es implementar dos clases:
	- Una clase `Club`, que representa un club deportivo que tiene una colección de socios.
	- Una clase `Membership`, que representa un socio.
3. Sin modificar la clase `Membership`, consigue que los dos métodos de la clase `Club` funcionen correctamente.
4. Haz un commit con el mensaje más descriptivo que seas capaz de redactar acerca de la funcionalidad que has implementado.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0056">
Mostrar solucion
</button>
<div id="0056" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/wj37rrcJQXE)

</div> 


### Actividad 0057

1. Continuando con la actividad 0055, crea dentro del directorio del proyecto de dicha actividad una nueva carpeta llamada `miMusica` y almacena en ella 5 archivos mp3 que se relacionan a continuación:
	- [Sueno de Dhalia: Creo en ti](assets/miMusica/Sueno de Dhalia-Creo en ti.mp3)
	- [Martin Oakson: Dhalia summer](assets/miMusica/Martin Oakson-Dhalia summer.mp3)
	- [Other Noises: Summer and winter](assets/miMusica/Other Noises-Summer and winter.mp3)
	- [Solange Jimenez: Nadie como tu](assets/miMusica/Solange Jimenez-Nadie como tu.mp3)
	- [Sueno de Dhalia: Encanto natural](assets/miMusica/Sueno de Dhalia-Encanto natural.mp3)
2. Modifica el constructor de la clase `MusicOrganizer` para que permita, al crear un objeto de dicha clase, indicar por parámetro el nombre de la carpeta donde están los archivos mp3 que manejará el organizador.
3. Testea los cambios y haz un commit de los mismos.
4. Implementa un método llamado `playRandom` que reproduzca una de las canciones del organizador al azar. Investiga la clase `Random` del paquete `java.util` y su método `nextInt` para cumplir tu cometido.
5. Testea los cambios y haz commit de los mismos.
6. Implementa un método llamado `playShuffle` que permita reproducir los primeros segundos de cada canción en orden aleatorio y que cumpla los siguientes requisitos:
	- Cada canción debe reproducirse una única vez y deben reproducirse todas.
	- Los contadores de reproducción deben actualizarse correctamente.
	- Debe mostrar por pantalla los detalles de la canción que está sonando en este momento.b
7. Testea los cambios y haz commit de los mismos.

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0057_pista1a">
Mostrar pista 1 de solución A
</button>
<div id="0057_pista1a" class="collapse">
La solución más sencilla es hacer un shuffle de los tracks que contiene el `ArrayList` del atributo `tracks`.
</div> 

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0057_pista2a">
Mostrar pista 2 de solución A
</button>
<div id="0057_pista2a" class="collapse">
A través de la clase `Collections` de la librería estándar de Java es posible conseguir hacer un shuffle de un `ArrayList`.
</div> 

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0057_pista1b">
Mostrar pista 1 de solución B
</button>
<div id="0057_pista1b" class="collapse">
Otra solución estaría basada en hacer una copia del `ArrayList` contenido en el atributo `tracks`.
</div> 

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0057_pista2b">
Mostrar pista 2 de solución B
</button>
<div id="0057_pista2b" class="collapse">
Una vez hecha la copia, podemos seleccionar aleatoriamente una canción de la copia, reproducirla y eliminarla de la lista.
</div> 

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0057_pista3b">
Mostrar pista 3 de solución B
</button>
<div id="0057_pista3b" class="collapse">
Para hacer una copia de un `ArrayList` se deben utilizar las siguientes dos líneas:

{% highlight java %}
ArrayList<TipoDeElementos> copia = new ArrayList<TipoDeElementos>();
copia = (ArrayList)original.clone();
{% endhighlight %}
</div> 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0057">
Mostrar solucion
</button>
<div id="0057" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/iaWfx9hc8I8)

Ṕuedes consultar el código fuente solución de esta actividad en el repositorio `0051` de mi página de GitHub. Ten cuidado porque también se encuentran disponibles las soluciones en dicho repositorio de las siguientes actividades.
</div> 


### Proyecto auction

[Ver explicación en Youtube](http://youtu.be/QxYKmDYpPsk)

	

### Actividad 0058

1. Clona el repositorio `auction` en la carpeta `0058` de tu ordenador.
2. Crea un objeto `Auction` y varios objetos `Person`.
3. Añade un par de items para ser subastados.
4. Haz un par de pujas sobre cada item.
5. Echando un vistazo a los atributos definidos en el código fuente de cada clase, ¿qué objetos de otras clases del proyecto y cuántos puede almacenar internamente un objeto `Auction`? ¿Y un objeto `Bid`? ¿Y un objeto `Lot`?
6. Intenta entender, mirando en el código fuente, qué sucede cuando:
	1. Se crea el objeto de tipo `Auction`
	2. Se crean varios objetos de tipo `Person`
	3. Se añaden items sobre los que pujar
	4. Un usuario puja sobre algún item en concreto

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0058">
Mostrar solucion
</button>
<div id="0058" class="collapse">
[Ver vídeo en Youtube](http://www.youtube.com/watch?v=7s3xt6egv_k)

</div>


### Palabra reservada null

[Ver explicación en Youtube](http://youtu.be/P7zM_3-5CxA)


### Objetos anónimos

[Ver explicación en Youtube](http://youtu.be/c0DRDIagCq8)


### Actividad 0059

1. Partiendo del código de la actividad 0058, reescribe el método `makeABid` de la clase `Auction` para usar donde sea posible un objeto anónimo en lugar de un objeto con nombre.
3. Testea los cambios y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0059">
Mostrar solucion
</button>
<div id="0059" class="collapse">
[Ver vídeo en Youtube](http://www.youtube.com/watch?v=gdW-X5o2xVQ)

</div> 


### Invocaciones de métodos en cadena

[Ver explicación en Youtube](http://youtu.be/Etf_5WCzOKg)


### Actividad 0060

1. Partiendo del código de la actividad 0059, añade un método denominado `close` a la clase `Auction`. Debe mostrar los detalles de todos los items que se estén subastando. De aquellos por los que haya habido pujas se debe indicar el nombre de la persona que ha hecho la puja más alta y el valor de dicha puja; del resto debe indicar que no ha habido pujas.
2. Testea los cambios y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0060">
Mostrar solucion
</button>
<div id="0060" class="collapse">
[Ver vídeo en Youtube](http://www.youtube.com/watch?v=pj8alhMdjCc)

</div>


### Actividad 0061

1. Partiendo del código de la actividad 0060, añade un método denominado `getUnsold` a la clase `Auction` que devuelva una colección de todos los items por los que no habido ninguna puja en este momento y no imprima nada por pantalla.
2. Testea los cambios y haz un commit.

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0061_pista1">
Mostrar pista
</button>
<div id="0061_pista1" class="collapse">
La cabecera del método debe ser:

{% highlight java %}
public ArrayList<Lot> getUnsold()
{% endhighlight %}
</div> 

<!--<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0061">
Mostrar solucion
</button>
<div id="0061" class="collapse">
[Ver vídeo en Youtube]()

</div> -->


### Actividad 0062

1. Partiendo del código de la actividad 0061, imagina que la clase `Auction` tiene un método que permite eliminar un objeto `Lot` de la colección de objetos `Lot`. Asumiendo que cuando se produce esta eliminación el número identificativo del resto de objetos `Lot` no se modifica, piensa y escribe en tu cuadernoque problemas podría suponer para el correcto funcionamiento del método `getLot`.
2. Reescribe el método `getLot` para que, en el caso de que implementaramos ese imaginario método que elimina objetos `Lot` de la colección de objetos `Lot` de la clase `Auction`, dicho método `getLot` siguiera funcionando correctamente.
3. Testea los cambios y haz un commit.
4. Implementa en la clase `Auction` un método denominado `removeLot` que reciba como parámetro un entero que represente el número identificador de un item y elimine dicho item de la colección de items. No se puede asumir que un item n estará en la posición n-1 por la posibilidad de que haya borrado de elementos. Este método debe devolver el elemento eliminado o `null` en caso de que dicho elemento no exista.
5. Testea los cambios y haz un commit.

<!--<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0062">
Mostrar solucion
</button>
<div id="0062" class="collapse">
[Ver vídeo en Youtube]()

</div> -->


### Actividad 0063

1. A partir del código de la actividad 0056 (proyecto `club`), implementa un método en la clase `Club` denominado `joinedMonth` con el siguiente comentario:

	```
	/** 
	 * Calcula el numero de socios que se dieron de alta en un mes determinado. 
	 * En caso de que el parametro contenga un valor no valido se muestra por pantalla el error.
	 * @param month El mes en el que estamos interesados
	 * @return El numero de socios que se dieron de alta dicho mes
	 */
	```

2. Testea los cambios y haz un commit.

3. Implementa un método en la clase `Club` denominado `purge` con el siguiente comentario:

	```
	/** 
	 * Todos los socios que se han dado de alta un determinado mes de un determinado año se
	 * dan de baja. En caso de que el parametro month contenga un valor no valido se muestra 
	 * por pantalla el error.
	 * @param month El mes en el que estamos interesados
	 * @param year El año en el que estamos interesados
	 * @return Una coleccion con los socios que se han dado de baja del club
	 */
	 ```

4. Testea los cambios y haz un commit.


### Actividad 0064

1. Clona el repositorio `products` de mi página de Github en un directorio llamado `0064`.
2. El proyecto `products` es un programa para ayudar a una tienda a llevar la gestión de los productos que vende. Nos interesan de momento las clases `Product` y `StockManager`:
	- La clase `Product` representa un producto que es vendido por la tienda. Cada producto se identifica por un número entero (`id`), por un nombre e incluye el número de unidades presentes en el almacen de la tienda. Esta clase está ya codificada y no debes modificarla.
	- La clas `StockManager` es la que representa el gestor del stock de la tienda y usa un `ArrayList` para guardar todos aquellos productos que vende la tienda. En estos moemntos solo el método `addProduct` funciona correctamente.
3. Codifica el método `printProductDetails` de la clase `StockManager`; para ello haz uso del método `toString` de la clase `Product`.
4. Testea los cambios y haz un commit.
5. Codifica el método `findProduct` de forma que su tiempo de ejecución sea el menor posible.
6. Testea los cambios y haz un commit.
7. Codifica el método `numberInStock`. Evita en lo que puedas la redundancia de código y piensa qué debe hacer y devolver el método en caso de que el `id` pasado como parámetro no coincida con ningún producto de los existentes.
8. Testea los cambios y haz un commit.
9. Codifica el método `delivery` y ten en cuenta, como con el método anterior, cómo se tiene que comportar en caso de que no haya ningún producto con el `id` indicado.
10. Testea los cambios y haz un commit.


### Actividad 0065

1. A partir del código terminado de la actividad 0064, implementa un método en la clase `StockManager` que imprima los detalles de todos los productos cuyo stock está por debajo de un determinado número que será pasado como parámetro al método.
2. Testea los cambios y haz un commit.
3. Modifica el método `addProduct` para que no permita añadir un producto que tenga un `id` de otro producto ya existente.
4. Testea los cambios y haz un commit.
5. Implementa un método en la clase `StockManager` que permita encontrar productos por su nombre en vez de por su `id`. La cabecera del método debe ser: 

	```
	public Product findProduct(String name)
	```

### Introducción a los arrays

[Ver explicación en Youtube](http://youtu.be/eTKe-JpiPEw)


### Declaración, inicialización y uso de arrays

[Ver explicación en Youtube](http://youtu.be/kADN6dgmNi0)


### Actividad 0066

1. Escribe en tu cuaderno la declaración de una variable array llamada `people` que pueda almacenar objetos de tipo `Person`.
2. Escribe en tu cuaderno la declaración de una variable array llamada `vacant` que pueda almacenar objetos de tipo `boolean`.
3. ¿Qué errores detectas en las líneas de código siguiente?

	```
	[]int counts;
	boolean[5000] occupied;
	```

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0066">
Mostrar solucion
</button>
<div id="0066" class="collapse">
Un solución al apartado 1 sería:

{% highlight java %}
Person[] people;
{% endhighlight %}

Una solución al apartado 2 sería:

{% highlight java %}
boolean[] vacant;
{% endhighlight %}

En el apartado 3 hay 2 errores: en la primera línea los paréntesis deben ir detras del tipo de dato y en la segunda no debe de indicarse en la declaración el número de elementos del array. El código corregido sería:

{% highlight java %}
int[] counts;
boolean[] occupied;
{% endhighlight %}
</div>



### Actividad 0067

1. Dadas las declaraciones siguientes, escribe en tu cuaderno como harías que: `readings` fuera capaz de almacenar 16 elementos de tipo `double`; `url` fuera capaz de almacenar 19 elementos `String`; `machines` fuera capaz de almacenar 5 elementos de tipo `TicketMachine`:

	```
	double[] readings;
	String[] urls;
	TicketMachine[] machines;
	```

2. ¿Cuántos objetos `String` se crean al ejecutarse la siguiente línea?

	```
	String[] labels = new String[20];
	```

3. ¿Que errores detectas en la siguiente línea? ¿Cómo se podrían subsanar?

	```
	double[] prices = double(50);	
	```

4. ¿Qué valores toman por defecto los elementos del siguiente array?

	```
	boolean[] occupied = new boolean[3];
	```

5. Escribe en tu cuaderno cómo se declara e inicializa un array de tipo `long` y cómo se guardan en él los 4 primeros números negativos.


<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0067">
Mostrar solucion
</button>
<div id="0067" class="collapse">
La solución al apartado 1 sería:

{% highlight java %}
readings = new double[16];
urls = new String[19];
machines = new TicketMachine[5];
{% endhighlight %}

<div class="hidden">
</div>

Cuando se ejecuta la línea de código del apartado 2 no se crean ningún objeto de tipo `String`. El `array` creado dispone de 20 elementos con valor `null`.

En el apartado 3, los errores consisten en la utilización de los paréntesis al final de la línea (deberían ser unos corchetes( y en la falta del operador `new`. Este sería el código corregido:

{% highlight java %}
double[] prices = new double[50];
{% endhighlight %}

<div class="hidden">
</div>

En el apartado 4, los 3 elementos del array toman valor `false`, que es el valor al que se inicializan automáticamente los elementos de un array de elementos de tipo `boolean`.

La solución al apartado 5 sería:

{% highlight java %}bluej
long[] numeros = new long[4];
numeros[0] = -1;
numeros[1] = -2;
numeros[2] = -3;
numeros[3:] = -4;
{% endhighlight %}
</div>



### Bucle for: introducción

[Ver explicación en Youtube](http://youtu.be/L5IzjfYjsjY)


### Bucle for: estructura

[Ver explicación en Youtube](http://youtu.be/Qksp7c01Ssw)


### Bucle for: uso con arrays

[Ver explicación en Youtube](http://youtu.be/vmudvJgZAZM)


### Actividad 0068

Si partimos de un código como el siguiente:

{% highlight java %}
ArrayList<String> planetas = new ArrayList<>();
planetas.add("Tierra");
planetas.add("Marte");
planetas.add("Pluton");{% endhighlight %}

<div class="hidden">
</div>

Se pide que:

1. Escribas en el cuaderno y pruebes en el CodePad de BlueJ el código necesario para eliminar todos los elementos del ArrayList `planetas` usando un bucle `while` e iteradores.

2. Escribas en el cuaderno y pruebes en el CodePad de BlueJ el código necesario para eliminar todos los objetos del ArrayList `planetas` usando un bucle `for` tradicional e iteradores (teniendo en cuenta que el último campo de un bucle `for` puede quedar vacío).



<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0068_pista1">
Mostrar pista
</button>
<div id="0068_pista1" class="collapse">
La cabecera del bucle debe ser del tipo:

{% highlight java %}
for (xxxxxx ; xxxxxx ; )
{% endhighlight %}
</div> 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0068">
Mostrar solucion
</button>
<div id="0068" class="collapse">
Un solución al apartado 1 sería:

{% highlight java %}
Iterator<String> it = planetas.iterator();
while (it.hasNext()) {
	String planeta = it.next();
	it.remove();
}
{% endhighlight %}

Y una solución del apartado 2 sería:
{% highlight java %}
for (Iterator<String> it2 = planetas.iterator(); it2.hasNext(); ) {
	String planeta = it2.next();
	it2.remove();
}
{% endhighlight %}
</div>


### Actividad 0069

1. Clona el proyecto `weblog-analyzer` de mi página de GitHub en la carpeta `0069`. Se trata de un programa que nos permite analizar un archivo log de un servidor web. Este archivo, cuyo nombre es `weblog.txt`, contiene una línea por cada petición que el servidor web ha recibido indicando el día y hora de la misma en formato `YYYY M DD HH MM`.

2. Crea un objeto de tipo `LogAnalyzer` e invoca su método `analyzeHourlyData`.

3. Invoca ahora el método `printHourlyCounts`, que imprime los resultados del análisis llevado a cabo por el método anterior.

4. ¿Cuál es el momento del día en el que el servidor web recibe más peticiones?

5. Estudia cómo funciona la clase `LogAnalyzer` teniendo en cuenta que la clase `LogfileReader` (cuyos objetos son capaces de mirar en el archivo `weblog.txt` e interpretar ỳ proveer a otros objetos con los datos que en el archivo figuran) la vamos a ver de modo abstracto: es decir, como es muy compleja, solo vamos nos vamos a fijar en qué métodos tiene disponible y en qué hacen y no en cómo están estos codificados.

6. ¿A qué se parece el funcionamiento de la clase `LogfileReader`?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0069">
Mostrar solucion
</button>
<div id="0069" class="collapse">
El momento del día en el que el servidor está más ocupado es a las 18:00 horas, ya que recibe 237 peticiones.

La clase `LogfileReader` funciona de forma parecida a los iteradores. Tiene implementados los métodos `hasNext`, `next` y `remove`. El método `next` devuelve objetos de la clase `LogEntry`.
</div>


### Actividad 0070

1. Partiendo del código de la actividad 0069, ¿qué sucedería si en la condición del `for` del método `printHourlyCounts` de la clase `LogAnalyzer` cambiamos el símbolo `<` por `<=`?

2. Reescribe el cuerpo del método `printHourlyCounts` para que use, en vez de un bucle `for`, un bucle `while`.

3. Testea los cambios y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0070">
Mostrar solucion
</button>
<div id="0070" class="collapse">
Cuando hacemos el cambio propuesto en el apartado 1, aparece un mensaje de error que indica que se ha generado la excepción:

```
java.lang.ArrayIndexOutOfBoundsException: 24
at LogAnalyzer.printHourlyCounts(LogAnalyzer.java:48)
```

Esto indica que hemos intentado acceder a una posición del array `hourCounts` fuera de los límites del mismo.

La solución del apartado 2 sería:


{% highlight java %}
public void printHourlyCounts()
{       
    System.out.println("Hr: Count");
    int index = 0;
    while (index < hourCounts.length) {
        System.out.println(index + ": " + hourCounts[index]);
        index++;
    }           
}
{% endhighlight %}

</div>



### Actividad 0072

1. Suponiendo que este método fuera parte de una clase, corrige todos los errores que encuentres:

	```
	/**
	* Print all the values in the marks array that are
	* greater than mean.
	* @param marks An array of mark values.
	* @param mean The mean (average) mark.
	*/
	public void printGreater(double marks, double mean)
	{
		for(index = 0; index <= marks.length; index++) {
			if(marks[index] > mean) {
				System.out.println(marks[index]);
			}
		}
	}
	```

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0072">
Mostrar solucion
</button>
<div id="0072" class="collapse">

Los errores existentes en el código son:

1. El parámetro `marks`, conforme a lo que dice el comentario y al uso que se le da en el método, es un array. Por tanto, en la cabecera del método debe figurar `double[] marks` en vez de `double marks`.

2. En la cabecera del `for` no se ha delarado la variable `index` como de tipo entero.

3. En la condición del `for` debemos usar el operador menor que en vez del menor o igual que si no queremos que se genere una excepción `ArrayIndexOutOfBoundsException`.

El código corregido sería:

{% highlight java %}
public void printGreater(double[] marks, double mean)
{
	for(int index = 0; index < marks.length; index++) {
		if(marks[index] > mean) {
			System.out.println(marks[index]);
		}
	}
}
{% endhighlight %}

</div>



### Uso de un servidor remoto con git: nociones básicas

[Ver explicación en Youtube](http://youtu.be/AUKC_waNKDE)



### Actividad 0071

1. Conforme a los datos que te proporcionará el profesor, clona en tu equipo el repositorio del servidor indicado.

2. Configura en el repositorio un archivo `.gitignore` para ignorar los archivos con extensiones `class`, `ctxt` y `bluej`.

3. Crea un archivo denominado `Prueba.java` vacío en la carpeta del repositorio.

4. Abre esa carpeta desde BlueJ (menu _Open_ > _Open non BlueJ_) y codifica la clase `Prueba` para que tenga dos atributos: uno llamado `atributo1` que sea de tipo entero y otro, llamado `atributo2`, que sea de tipo `ArrayList` de `String`. Crea también un constructor que inicialice a 0 el primer atributo y a un `ArrayList` vacío el segundo.

5. Haz un commit y envía el commit al servidor.

6. Añade un método getter para el atributo `atributo1`.

7. Haz un commit y envía el commit al servidor.

8. Avisa al profesor para que haga alguna modificación en ese repositorio en el servidor.

9. Cuando te de el ok, traete los cambios introducidos por el profesor al repositorio local de tu equipo.



### Actividad 0073

1. A partir del código de la actividad 0070, añade a la clase `LogAnalyzer`  un constructor que pueda tomar como parámetro el nombre del archivo de log a analizar. Usa la clase `LogFileCreator` para crear tu propio archivo de log y comprueba que puedes analizarlo con la clase `LogAnalyzer`.

2. Testea los cambios y haz un commit.

3. Crea un método llamado `numberOfAccesses` que se pueda ejecutar después del método `analyzeHourlyData` y que devuelva el número total de accesos al servidor web registrados en el archivo de log. 

4. Testea los cambios y haz un commit.

5. Añade un método denominado `busiestHour` a la clase `LogAnalyzer` que se pueda ejecutar después del método `analyzeHourlyData` y que devuelva en qué hora el servidor tuvo que responder a más peticiones. 

6. Testea los cambios y haz un commit.

7. Añade un método denominado `quietestHour` a la clase `LogAnalyzer` que se pueda ejecutar después del método `analyzeHourlyData` y que devuelva la hora a la que el servidor estuvo menos sobrecargado. Para testear este método asegúrate de que lo pruebas con un archivo de log en el que ha habido accesos a todas las horas.

8. Testea los cambios y haz un commit.

9. Añade a la clase `LogAnalyzer` un método que se pueda ejecutar después del método `analyzeHourlyData` y que calcule el período de dos horas consecutivas con más carga del día y devuelva un entero con la primera hora de dicho periodo.

10. Testea los cambios y haz un commit.



### Examen de la segunda evaluación

* [Enunciado](/assets/videos/20140307examenSegundaEvaluacion5536.html)
* [Solución](https://github.com/miguelbayon/tarlam)
* [Calificaciones](https://docs.google.com/spreadsheet/pub?key=0AojaZeMGL7HsdGMzbEtpQjN0a2F1S0U5QU9iSnBYRWc&single=true&gid=1&output=html)



### Actividad 0074

1. A partir del código de la actividad 0073, fíjate en los atributos, el constructor y en los métodos getter `getHour` y `getMinute` de la clase `LogEntry` e implementa en esa clase los métodos getter `getDay`, `getMonth` y `getYear`.

2. Testea los cambios y haz un commit.

3. Añade a la clase `LogAnalyzer` un método con la siguiente cabecera:

	```
	/** 
	 * Analyze the hourly accesses in the given date
	 *
	 * @param day 	The given day
	 * @param month The given month
	 * @param year  The given year
	 */
	```

4. Testea los cambios y haz un commit.

5. Añade a la clase `LogAnalyzer` el atributo que consideres necesario para que puedas luego añadir un par de métodos llamados `analyzeDailyData` y `printDailyCounts` que lleven a cabo el análisis y la impresión de los accesos que se llevan a cabo en función del número del día del mes.

6. Testea los cambios y haz un commit.



### Actividad 0075

Partiendo del código de la actividad 0074, nuestro objetivo es conseguir que nuestra aplicación sea capaz de analizar archivos de log que presenten un campo de datos adicional. 

La mayoria de servidores web incluyen en sus registros un valor numérico que indica si el acceso fue un acceso exitoso o no. Por ejemplo, el valor 200 indica que el acceso fue exitoso mientras que el valor 403 indica que se solicito un documento a cuyo acceso no se tenía permiso y el 404 significa que el documento solicitado no pudo encontrarse en el servidor. 

Se pide que la clase `LogAnalyzer` sea capaz de hacer un análisis por horas de los accesos exitosos o no al servidor web.

Esta actividad es una actividad bastante compleja ya que se requieren cambios en la mayoría de clases del proyecto.

Realiza tantos commits como consideres oportunos. Deberías ser capaz de pensar en el mensaje del commit antes incluso de llevar a cabo los cambios.

<!--
Los objetos LogEntry son capaces ahora de almacenar también un codigo de error.

El constructor de LogEntry admite ahora un parametro indicando el codigo de error.

Añadido un getter para el codigo de error en la clase LogEntry.

La clase LogfileCreator es capaz ahora de crear archivos de log con una nueva columna que representa el codigo de error.

Añadido el metodo analyzeHourlyErrorsData a la clase LogAnalyzer.

Añadido el metodo printHourlyErrorsCounts a la clase LogAnalyzer.

-->


### Actividad 0076

1. Ahora que ya hemos estudiado los bucles for, for-each, while y los iteradores, se pide que investigues en qué consiste otro de los bucles de los que dispone Java: el bucle `do-while`.

2. Escribe en el CodePad el código necesario para, usando un bucle do-while, imprimir por pantalla los números del 1 al 10.




### Actividad 0077

1. Clona de mi página de GitHUb el repositorio `music-organizer-v3` en el directorio `0077`.

2. Reescribe el método `listAllFiles` de la clase `MusicOrganizer` sustituyendo el bucle for-each por un bucle for.

3. Testea los cambios y haz un commit.

4. Reescribe el método `listAllFiles` de la clase `MusicOrganizer` sustituyendo el bucle for por un bucle do-while.

5. Testea los cambios y haz un commit.



### Actividad 0078

1. Clona de mi página de GitHUb el repositorio `music-organizer-v4` en el directorio `0078`.

2. Reescribe el método `findFirst` de la clase `MusicOrganizer` usando un bucle do-while en vez del bucle while actual. 

3. Testea cuidadosamente tu método. Prueba a realizar búsquedas que tengan éxito y otras que no lo tengan. Prueba también con búsquedas en las que el archivo a buscar sea el primero de todos y otras en las que sea el último de la lista. Una vez que hayas comprobado que el método es correcto, haz un commit.



### Actividad 0079

1. Investiga por tu cuenta para qué y cómo se usa en Java la sentencia `switch-case`. 

2. Escribe un ejemplo en el CodePad de BlueJ testeando el uso de esta sentencia.



### Actividad 0080

1. La empresa DoggySoft se dedica al desarrollo de aplicaciones. Hasta ahora disponía de un call center donde los usuarios llamaban para resolver sus problemas con el software de la compañía. Debido a la crisis, la empresa decide eliminar dicho call center e implementar un software que permita hacer creer a los clientes que el departamento de atención al cliente existe y es accesible mediante un chat online. Dicho software está practicamente terminado y lo puedes clonar desde mi página de Github (repositorio `tech-support`).

2. Abre el proyecto en BlueJ y, sin mirar el código fuente (cosa que todavía no nos interesa), crea un objeto de la clase `SupportSystem` e invoca el método `start` de dicho objeto.

3. Prueba cómo funciona el chat de atención al cliente escribiendo mensajes, a ser posible en inglés. Para terminar la conversación escribe `bye`.



### Actividad 0081

<!--
- My system crashes all the time
- I am using Linux. Should your program run on Linux?
- I really need help! Your program is not working!
- I hate you
- bye
-->

1. Clona de mi página de Github el repositorio `tech-support-v1` a una carpeta llamada `0081`. Se trata de una versión inicial del programa que probaste en la actividad 0080.

2. Ábrelo con BlueJ, crea un objeto de la clase `SupportSystem` e invoca al método `start` de dicho objeto.

3. ¿Cuántas respuestas diferentes es capaz de proporcionarte el chat implementado en esta versión?

4. ¿Cómo son las relaciones de dependencia entre las clases pertenecientes a este proyecto? ¿Cuál y por qué dirías que es la clase principal?

6. Para seguir con nuestras investigaciones, crea una instancia de la clase `InputReader`. ¿Qué métodos tiene disponibles la clase `InputReader`? ¿Qué retornan? Invoca los métodos disponibles sobre el objeto que has creado. ¿Cuál es la función de la clase `InputReader`? 

7. Continuando con nuestras investigaciones, crea una instancia de la clase `Responder`. ¿Qué métodos tiene disponibles la clase `Responder`? ¿Qué retornan? Invoca los métodos disponibles sobre el objeto que has creado. ¿Cuá es la función de la clase `Responder`?

8. ¿Cuántos atributos tiene la clase `SupportSystem`? ¿Dónde se inicializan y a qué?

9. ¿Qué métodos tiene disponibles la clase `SupportSystem`? ¿Qué devuelven? 

10. ¿Qué hacen los métodos `printWelcome` y `printGoodbye` de la clase `SupportSystem`? ¿Cuándo se ejecutan estos métodos?

11. ¿Qué tipo de bucle se usa en el método `start` de la clase `SupportSystem`? ¿Hay una variable índice? ¿Cuál es la función de ese bucle? ¿Qué sucede si la variable `finished`se inicializa en vez de a `false ` a `true`? ¿Qué parte del if del bucle ha de ejecutarse para que no haya luego más iteraciones?

12. La respuesta que el chat ofrece, ¿depende de la frase introducida por el usuario?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0081">
Mostrar solucion
</button>
<div id="0081" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/K8Mymy_i9ZA)

</div> 



### Consultar la documentación de una clase de Java

[Ver explicación en Youtube](http://youtu.be/ldcycoCb_pA)

[Enlace a la documentación de Java 7 online](http://docs.oracle.com/javase/7/docs/api/)

[Enlace a la documentacion de Java 7 en formato zip](https://googledrive.com/host/0B4jaZeMGL7HsV1NBNUhUVTVjRlU/jdk-7u51-apidocs.zip)

[Enlace alternativo a la documnentacion de Java 7 en formato zip](/recursos/jdk-7u51-apidocs.zip)


<!--
- ¿Cómo es de grande la libreria estandar de clases de Java? 
	Miles de clases
	La libreria estandar de clases de Java es muy grande
	Es imposible saberla de memoria

- ¿Que tenemos que conocer?
	Las clases más importantes
	Los métodos más usados de dichas clases
	Saber cómo consultar el resto de clases y métodos

- ¿Cómo se consulta la documentacion de la API?
	Desde un navegador
	Online u offline
	archivo index.html de la carpeta api del archivo descargado

- ¿Cómo esta estructurada la documentación?
	Tres partes
	Lista de paquetes
	Lista de clases 
	Detalles de la clase seleccionada
-->



### Actividad 0082

1. Investiga la documentación de la clase `String` y de otro par de clases a tu elección. ¿Cómo es la estructura de la documentación de una clase? ¿Qué secciones son comunes a la documentación de todas las clases?

2. Consulta el método `startsWith` de la clase `String`. ¿Cuántas versiones hay de este método? ¿Qué diferencias hay entre una y otra? Escribe código en el CodePad de BlueJ para testear ambos métodos de forma que obtengas como valores devueltos `true` o `false` para ambos métodos.

3. ¿Hay algún método en la clase `String` que compruebe si una cadena termina con un determinado sufijo? Si existe, ¿cuál es? Escribe código en el CodePad de BlueJ para testear este método de forma que obtengas valores devueltos `true` o `false`.

4. ¿Hay algún método en la clase `String` que devuelva el número de caracteres de una cadena? Si existe, ¿cuál es?, ¿qué parámetros lleva?, ¿que tipo de valor devuelve? Escribe código en el CodePad de BlueJ para testear este método.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0082">
Mostrar solucion
</button>
<div id="0082" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/8kkYVBJf92s)

</div>


### Interfaz vs implementación

[Ver explicación en Youtube](http://youtu.be/fGWWeN10FvM)

<!-- 
- ¿Qué es la interfaz de una clase?
	- Lo que vemos en la documentacion

- ¿Qué información incluye la interfaz?	
	- El nombre de la clase
	- La descripción de la clase
	- La lista de constructores
	- La lista de métodos
	- La información de cada constructor: parametros y pequeña descripcion
	- La información de cada metodo: valores de retorno, parametros y pequeña descripción

- ¿Qué es la implementación de una clase?
	- Todo el código fuente correspondiente a una clase
	- Incluye cabecera de la clase, atributos, constructores y metodos

- ¿Que nos aporta la interfaz de una clase?
	- Solo consultando la interfaz somos capaces de usar esa clase
	- No es necesario ver su implementacion
	- Otra vez es un ejemplo de abstraccion

- ¿Qué es la interfaz de un método?
	- La información que necesitamos para usarlo	
	- Su nombre	
	- Un modificador de acceso (más adelante)
	- El tipo del valor de retorno
	- La lista de parametros

- ¿Tiene otros significados el termino interfaz en Java?
	- Interfaz grafica de los programas (mas adelante)
	- Construcccion del lenguaje (mas adelante)
-->


### Actividad 0083

1. Partiendo del código de la actividad 0081, implementa la posibilidad de que el usuario pueda utilizar espacios a discrección antes o después de la palabra `bye` para salir del chat.

2. Testea los cambios y haz un commit.

3. Implementa la siguiente funcionalidad: el chat debe terminar siempre que el usuario ponga `bye` independientemente de la combinación de letras mayúsculas y minúsculas utilizada por el usuario (es decir, por ejemplo puede introducir `Bye` o `bYe` y el chat debe finalizar en ambas situaciones).

4. Testea los cambios y haz un commit.

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0083_1">
Mostrar pista 1
</button>
<div id="0083_1" class="collapse">
Investiga en la documentación de la clase `String` si hay algún método que nos pueda ayudar a completar el ejercicio.
</div>

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0083_2">
Mostrar pista 2
</button>
<div id="0083_2" class="collapse">
Investiga los métodos `trim` y `toLowerCase` de la clase `String`.
</div> 

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0083">
Mostrar solucion
</button>
<div id="0083" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/JZ55r3zTDd4)

</div>


### String: inmmutabilidad y métodos

[Ver explicación en Youtube](http://youtu.be/e903wIMZQ3Y)

<!--
- ¿En qué consiste la inmutabilidad de los objetos String?
	- No pueden cambiar su contenido una vez creadas
	- Diagrama explicando como funciona esto en memoria

- ¿Los métodos de la clase String no cambian el valor del objeto sobre el que se invocan?
	- No
	- Devuelven un String con el valor cambiado
	- Debemos asignar ese valor de nuevo a nuestra variable/atributo
-->



### Comparación de objetos String

[Ver explicación en Youtube](http://youtu.be/-0mM6W9ZMVM)

<!-- 
- ¿Puedo comparar objetos con ==?
	- Si se puede
	- Estamos comprobando que se trata del mismo objeto en memoria	

- ¿Cómo compruebo que dos objetos String tiene el mismo contenido?
	- Es un error comprobarlo con ==
	- Usar siempre el metodo equals de la clase String	

- ¿Por qué a veces funciona usar ==?
	- Las cadenas solo se crean una vez en memoria
	- Si ya hay una cadena con ese valor, se reutiliza

	String a = "hola";
	String b = "hola";
	a == b   //devuelve true!! "hola" solo existe una vez en memoria.
	b = b + "";
	a == b   //devuelve false!! Se creo un nuevo objeto string para b.

-->



### Actividad 0084

1. Vamos a partir del código de la actividad 0083. Actualmente se podría finalizar la sesión del chat usando una frase de estilo "  ByE, Bye!! ". Se pide que modifique el método `start` de la clase `SupportSystem` para que se compruebe que la frase introducida por el usuario contiene únicamente en texto `bye` independientemente del número de espacios usados antes y después y de la combinación de mayúsculas y minúsculas empleada.

2. Testea los cambios y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0084">
Mostrar solucion
</button>
<div id="0084" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/bDzA4g7bqtU)

</div>


### Actividad 0085

1. Consulta la documentación de la clase `Random`. Aunque habrá mucho contenido de la documentación que no entiendas, deberías ser capaz de contestar estas preguntas: ¿en qué paquete (package) está esta clase? ¿Cuántos constructores tiene la clase? ¿De qué tipo de datos podemos generar valores aleatorios?

2. Escribe en el CodePad el código necesario para generar e imprimir por pantalla 3 números enteros aleatorios.

3. Escribe en el CodePad el código necesario para generar e imprimir por pantalla 20 números enteros aleatorios entre 0 y 100 ambos inclusive.

4. Escribe en el CodePad el código necesario para generar e imprimir 10 valores booleanos aleatorios.

5. Escribe en el CodePad el código necesario para imprimir por pantalla aleatoriamente una de estas cadenas: "si", "no", "tal vez".

6. Escribe en el CodePad el código necesario para imprimir por pantalla aleatoriamente una de las cadenas contenidas en un `ArrayList` de `String` que crees previamente. No se permite escribir en el código ningún número de forma literal.

7. Escribe en el CodePad el código necesario para imprimir por pantalla aleatoriamente una de las cadenas contenidas en array tradicional que crees previamente. No se permite escribir en el código ningún número de forma literal.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0085">
Mostrar solucion
</button>
<div id="0085" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/oI9ai5Lab7A)

</div>


### Actividad 0086

1. Partiendo del código de la actividad 0083, modifica la clase `Responder` de forma que:
	1. Contenga un atributo de tipo `Random`.

	2. Contenga un atributo de tipo `ArrayList` de `String`.

	3. En el constructor se inicialicen los atributos añadidos y se añadan una serie de respuestas elegidas por ti al atributo de tipo `ArrayList` (al menos 5 respuestas).

	4. En el método `generateResponse` ya no se devuelva siempre la misma respuesta si no una elegida al azar por el programa entre las incluidas en el atributo de tipo `ArrayList`.


2. Testea los cambios y haz un commit con un nombre descriptivo de lo que ha cambiado en el programa gracias a los pasos seguidos en este actividad.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0086">
Mostrar solucion
</button>
<div id="0086" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/kmhjosBg2PY)

</div>



### Leer documentación de clases genéricas o parametrizadas

[Ver explicación en Youtube](http://youtu.be/AOzisqVXdtM)



### Importación de paquetes 

[Ver explicación en Youtube](http://youtu.be/FmQiQ_P5JTE)



### Actividad 0087 

1. Date de alta en GitHub. Es obligatorio fijar un avatar. Si no queréis usar vuestra foto por temas de privacidad podéis poner una en la que salgais de lejos o bien otra cosa. Mi recomendación es que uséis vuestra propia foto. Cuando busquéis trabajo como programadores es muy probable que os miren vuestro perfil de Github si decís que sabéis trabajar con git, así que es buena idea empezar a crearse una buena imagen en Internet.

2. Ejecuta en la consola de git, dentro de la carpeta de la actividad 0086, el siguiente comando:

	```
	git remote remove origin
	```

3. Investiga cómo crear en GitHub un repositorio y cómo subir el repositorio de la actividad 0086 que tienes en tu equipo.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0087">
Mostrar solucion
</button>
<div id="0087" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/HvdRDN10LUU)

</div>



### Actividad 0088

1. Investiga en qué consiste un objeto de la clase `HashMap` y cómo se utiliza. Para ello echa una vistazo a la documentación de `Map` y `HashMap` (dado que `HashMap` es una especialización de `Map`). Es normal que muchas de las cosas que aperecen en la documentación no las entiendas, ya que además de que nos faltan ciertos conocimientos, la documentación de estas clases no es demasiado buena. Lo importante es ver cuánto somos capaces de comprender por nuestra cuenta.

2. La clase `HashMap` es una clase genérica o parametrizada. Encuentra en la documentacion un método de dicha clase en el que esté involucrado uno de los objetos usados para dicha parametrización. ¿Crees que es posible que se pueda usar el mismo tipo de dato para ambos parámetros?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0088">
Mostrar solucion
</button>
<div id="0088" class="collapse">
Un método de la clase en el que están involucrados los objetos usados para la parametrizacion de la clase sería el método `get`. La documentación nos dice que devuelve un objeto de tipo `V` una vez que se le pasa un parámetro de tipo `K`.

Es perfectamente posible que el tipo de dato que se usa como clave sea el mismo que el que se usa como valor de un `HashMap`.
</div>




### Mapas y clase HashMap

[Ver explicación en Youtube](http://youtu.be/QhdMIxpvcfk)

<!--

- ¿Qué es un mapa?
	- Coleccion de pares de objetos
	- Uno de los objetos es la clave (key) y el otro el valor (value)	
- Ejemplo de mapa:
	- Diccionario
	- Prefijos
- ¿Cómo se recuperan los valores de un mapa?
	- A través de su clave
	- No se usan índices

-->


### Actividad 0089

1. Crea un nuevo proyecto con BlueJ llamado `0089` y, dentro de él, crea una clase llamada `AgendaTelefonica`. 

2. Utilizando un `HashMap`, implementa en dicha clase una agenda telefónica que disponga de los siguientes métodos:

	```
	public void enterNumber(String name, String number)

	public void lookupNumber(String name)
	```

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0089">
Mostrar solucion
</button>
<div id="0089" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/rVrpTZTccJQ)

</div>



### Actividad 0090

1. Leyendo la documentación de la clase `HashMap`, investiga la respuesta a las siguientes preguntas: 

2. ¿Cómo se puede saber cuántas entradas contiene un objeto de tipo `HashMap`?

3. ¿Qué sucede cuando se intenta añadir una entrada a un objeto `HashMap` con una clave (_key_) que ya existe como clave en dicho objeto?

3. ¿Qué sucede cuando se añade un objeto con una clave y, posteriormente, se añade el mismo objeto con una clave diferente?

4. ¿Cómo se puede comprobar si una determinada clave ya existe en un objeto de tipo `HashMap`?

5. ¿Qué sucede cuando se intenta buscar un valor (_value_) correspondiente a una clave que no existe en ese objeto `HashMap`?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0090">
Mostrar solucion
</button>
<div id="0090" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/cU8VxsHWAYc)

</div>



### Actividad 0091

1. Continuando con el código de la actividad 0089 e investigando en la documentacion, implementa, sin usar ningún bucle, el siguiente método:

	```
	/**
	 * Print all keys
	 */
	public void printAllNames()
	```

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0091">
Mostrar solucion
</button>
<div id="0091" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/nZolHYAi4xc)

</div>



### Actividad 0092

1. Partiendo del código de la actividad 0086, modifica la clase `Responder` y algo de la clase `SupportSystem`, para que, imaginando que el usuario introduzca una solo palabra en el chat, la aplicación le conteste con una frase relacionada con dicha palabra. Esto debe funcionar, al menos, para cuatro palabras diferentes que debes elegir tú. En caso de que el usuario no introduzca ninguna de las palabras elegidas por tí, la contestación del chat debe seguir el funcionamiento del código ya implementado.

2. Testea los cambios y haz un commit.
	
<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0092">
Mostrar solucion
</button>
<div id="0092" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/zsvfwjPXRN0)

</div>



### Conjuntos y clase HashSet

[Ver explicación en Youtube](http://youtu.be/PVmnj7S7C7s)

<!--

- ¿Para que nos sirve la clase Hashset?
	- Para crear conjuntos
- ¿Cómo creo un objeto HashSet?
	- Importando la clase
	- Inicializando el objeto
	- Clase generica
- ¿Cómo metemos elementos en un HashSet?
	- Meter un elemento dos veces no tiene efecto
- ¿Cómo recorremos todos los elementos de un HashSet?
- ¿En qué se parece a un ArrayList y por qué?
	- Mismos métodos y tratamiento:
		- add()
		- for-each
	- Ambos son colecciones
- ¿En qué se diferencia de un ArrayList?
	- No hay orden en los elementos
	- Un elemento solo puede estar una vez	
- ¿Hay otras clases para usar conjuntos?
	- Clase TreeSet
	- Ambos son conjuntos Set
	- Mismo comportamiento
	- Implementaciones diferentes
	- Una hace mejor una cosa y otra otra
	- Solo importante si interesa eficiencia
-->


### Actividad 0093

1. Investiga el uso del método `split` en la documentación de la clase `String` y pruébalo en el CodePad de BlueJ de forma que si tenemos una variable cadena con un determinado texto, seas capaz de mostrar dicho texto dividido por palabras línea a línea. Es decir, si nuestra cadena es "Estamos en clase de Programacion", tu código debería mostrar por pantalla:

	```
	Hola
	estamos
	en
	clase
	de
	Programacion
	```

2. ¿Habría algún problema en tu código anterior si entre dos palabras hay más de un espacio (dos o tres espacios, por ejemplo)? Pruébalo en el CodePad.

3. Investiga con el CodePad cómo usar el método `split` para poder separar una cadena cuyas palabras están separadas por comas, como por ejemplo: 

	"Mario,Alonso,Cid,71427450J,987256689"

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0093">
Mostrar solucion
</button>
<div id="0093" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/KLwAHlVuG-A)

</div>


### Actividad 0094

1. Partiendo del código de la actividad 0092, modifica el método `getInput` de la clase `InputReader` para que devuelva la primera de las palabras introducidas por el usuario.

2. Testea los cambios y haz un commit.

3. Modifica el método `getInput` de la clase `InputReader` para que devuelva un `HashSet` de objetos `String` que contenga todas las palabras que ha introducido el usuario (probablemente tengas que, a consecuencia de ese cambio, modificar más métodos de otras clases).

4. Testea los cambios y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0094">
Mostrar solucion
</button>
<div id="0094" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/8Gavn1EuLBs)

</div>



### Actividad 0095

1. Partiendo del código de la actividad 0094, modifica la clase `Responder` y algo de la clase `SupportSystem` para que el método `generateResponse` sea capaz de devolver una respuesta en cuanto identifique una palabra en el conjunto de palabras introducidas por el usuario.

2. Testea los cambios, haz un commit y luego haz un push a tu repositorio en Github.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0095">
Mostrar solucion
</button>
<div id="0095" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/SPnB9BiIuPA)

</div>



### Actividad 0096

1. Partiendo del código de la actividad 0095, modifica la clase `Responder` para que el sistema pueda dar respuesta a un conjunto de palabras introducidas por el usuario. Por ejemplo, si el usuario introduce únicamente "free app", la respuesta debe ser diferente a si introduce solo "app" o diferente de si introduce solo "free" pero igual que si introduce "app free". De igual manera, si el usuario introduce "problem linux crash", la respuesta ha de ser igual que si el usuario introduce "crash linux problem" pero diferente de si introduce "linux problem" o "crash linux". Es decir, el sistema debe responder a conjuntos de palabras.

2. Testea los cambios y haz un commit.

3. Modifica la clase `Responder` para que, en caso de que el sistema no reconozca ningun conjunto de palabras, no se repita dos veces una misma respuesta. En el caso de que el sistema se quede sin respuestas, éste debe responder diciendo que no ha entendido la frase del usuario.

4. Testea los cambios, haz un commit y luego haz un push a tu repositorio en Github.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0096">
Mostrar solucion
</button>
<div id="0096" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/GoSK1xo24x8)

</div>



### Documentación de clases

[Ver explicación en Youtube](http://youtu.be/WxkR0DHlpFc)

<!--
- ¿Por qué hay que documentar?
    - Usar la clase solo con su interfaz y con su documentacion    
    - Para entender una clase no hace falta leer su implementación
    
- ¿Que pasa si no documento?
    - Será dificil para otro o para ti más tarde entender tus clases
    - Solucion: leer la implementación para entender la clase
    - Esa solucion no funciona en el mundo real con aplicaciones grandes
        - Cientos de clases
        - Varios desarrolladores
    - Imagina tener que leer la implementación de la clase HashSet o Random    
    
- ¿Cuándo debo documentar?
    - Mientras escribo código
    
- ¿Cómo genero documentación?
    - javadoc
    - Se genera a partir de la interfaz y de los comentarios
    - Es el sistema que usa la librería de clases estándar
    
- ¿Como usar javadoc en BlueJ?
    - Selector "Source code" a "Documentation"
    - "Project documentation" en menu "Tools"
    
- ¿Que elementos son necesarios?
    - Nombre de la clase
    - Comentario describiendo para que sirve la clase
    - Numero de version
    - El autor de la clase
    - Documentación de todos los constructores y métodos:
        - El nombre del metodo
        - El tipo de dato que devuelve
        - El nombre de los parámetros y su tipo
        - Breve descripción de qué hace el metodo
        - NO indicar cómo lo hace
        - Breve descripción de que representa cada parametro
        - Breve descripción de que representa el valor devuelto

- ¿Cómo identifica javadoc comentarios a incluir?
    - Empiezan por /**
    - Comentarios justo encima de la clase: descripción de la misma
    - Comentarios justo encima de un metodo: descripcion del mismo
    
- ¿Qué etiquetas podemos usar para javadoc?
    @version
    @author
    @param
    #return
 -->


### Actividad 0097

1. Completa la documentación del código de la actividad 0091 y luego utiliza las opciones de BlueJ para generar dicha documentación.



### Público vs privado

[Ver explicación en Youtube](http://youtu.be/SR56ILDCkXQ)

<!--
- ¿Que son los modificadores de acceso?
    - Las palabras clave public o private

- ¿Dónde figuran?
    - Cabeceras de constructores y métodos
    - Declaraciones de atributos
    
- ¿Para que sirven?
    - Definen la visibilidad
    - public: pueden ser invocados desde fuera de la clase
    - private: solo pueden ser invocados desde dentro de la clase

- ¿Que tienen que vez con la implementacion y la interfaz?
    - Todo lo que es public es interfaz
    - Todo lo que private es implementacion
    
- ¿Por qué ocultar la implementación?
    - No es necesario falta conocer el interior de una clase
    - No se debe conocer el interior de una clase
    
- ¿Por qué no es necesario conocer el interior de una clase?
    - Con la documentacion debe bastar para usar una clase
    - Abstracción y modularización
    
- ¿Por qué no se debe conocer el interior de una clase?
    - Para no hacer una clase dependiente de otra
    - Un cambio en la implementacion no debe suponer nada
    - Acoplamiento
    - Buscamos bajo acoplamiento
    - Bajo acoplamiento significa un mantenimiento mas sencillo
    - Ejemplo: cambios implementacion ArrayList
    - Unico programador: actua como si no supiera la implementacion
    
¿Para qué usar métodos private?
    - Llevar a cabo tareas grandes de forma modular
    - printWelcome y printGoodbye
    - Un código que se ejecute repetidamente
    
¿Es buena idea usar atributos public?
    - Tenerlos private permite asegurar su integridad
    - Encapsulamiento
    - Muchos lenguajes no permiten atributos public
    
¿Hay otro modificadores de acceso?
    - Protected
    - No poner nada

-->



### Actividad 0098

1. Clona de mi página de GitHub el repositorio `scribble` y ábrelo con BlueJ. Se trata de un proyecto en el que hay dos clases principales: la clase `Canvas` es un lienzo donde poder dibujar; la clase `Pen` presenta un lapiz asociado a un objeto `Canvas` que nos permite hacer trazos sobre dicho objeto; finalmente, la clase `DrawDemo` tiene una serie de métodos que hacen dibujos prediseñados de prueba.

2. Abre el código fuente de la clase `Canvas` y cambia a la documentación del mismo. De esta manera vamos a simular que no somos capaces de ver la implementación de la clase `Canvas` y que solo podemos ver su interfaz a través de la documentación. Realiza la misma operación con la clase `Pen`.

2. Crea interactivamente un objeto de la clase `DrawDemo` y experimenta invocando sus métodos.

3. Lee el código fuente de la clase `DrawDemo` intentando entender como funciona cada método. Algunos de sus métodos hacen referencia a la clase `Color`. Esta clase está definida en el paquete `java.awt` y en ella se definen una serie de colores como, por ejemplo, el rojo a través de `java.awt.Color.RED`. 

4. Crea un objeto `Pen` con su constructor sin parámetros y experimenta invocando sus métodos leyendo antes en su documentación qué hace cada método.

5. Crea un objeto `Canvas` con su constructor de un solo parametro y e invocando sus métodos dibuja un círculo rojo cerca del centro del lienzo. Luego dibuja un rectángulo amarillo.



### Autocompletado de código en BlueJ

[Ver explicación en Youtube](http://youtu.be/jWS3W9xBHzQ)



### Actividad 0099

1. A partir del código de la actividad 0098, codifica un método en la clase `DrawDemo` llamado `drawTriangle` que permita dibujar un triangulo verde en las coordenadas pasadas como parámetro.

2. Testea los cambios y haz un commit.

3. Codifica un método en la clase `DrawDemo` llamado `drawPentagon` que permita dibujar un pentágono verde.

8. Testea los cambios y haz un commit.

9. Codifica un método en la clase `DrawDemo` llamado `drawPolygon(int n)` que permita dibujar un polígono regular con n lados, es decir, si `n` vale 3, será un triángulo, si vale 4 será un cuadrado, etc. 

10. Testea los cambios y haz un commit.

11. Codifica un método en la clase `DrawDemo` llamado `drawSpiral` que dibuje una espiral como la que se muestra a continuación.

	<img src="/images/spiral.png" class="img-responsive">

12. Testea los cambios y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0099">
Mostrar solucion
</button>
<div id="0099" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/Hr7kDzT_VqQ)

</div>



### Actividad 0100

1. Clona de mi página de GitHub el repositorio `bouncing-balls` en una carpeta llamada `0100`.

2. Para entender cómo funciona este proyecto, crea un objeto de la clase `BallDemo` e invoca su método `bounce`.

3. Se pide que modifiques el método `bounce` de la clase `BallDemo` para que el usuario introduzca por parámetro cuántas bolas quiere que aparezcan en pantalla. El radio y color de las bolas debe ser aleatorio. Su posicion de inicio también debe ser aleatoria, pero siempre de la mitad de la pantalla hacia la izquierda. La animación debe terminar cuando alguna bola se salga del suelo por la derecha. Por cada avance que hagas hasta conseguir obtener la solución final, realiza un commit.

4. Cuando hayas terminado la actividad sube tu proyecto a tu página de GitHub.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0100">
Mostrar solucion
</button>
<div id="0100" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/b-jLKZBH5Ek)

</div>


<div class="alert alert-info">	
	<div class="icono-alert"><i class="fa fa-exclamation fa-2x"></i></div>
	<div class="contenido-alert">
			<p>Recuerda que debes realizar un commit por cada funcionalidad que implementes, aunque sea pequeña. Evita a toda costa hacer commits enormes, o commits que corrigen un sinfín de cosas, o un único commit de cambios sin 
			relación alguna entre ellos.</p>		
	</div>
</div>



### Actividad 0101

1. Partiendo del código de la actividad 0101, implementa un nuevo método en la clase `BallDemo` denominado `boxBounce`. Este método debe dibujar un rectángulo en la pantalla y tantas bolas como se indiquen como parámetro en la invocación del método. Los objetos bola de esta actividad no serán del tipo `BouncingBall`: lo que debes hacer es crear una nueva clase denominada `BoxBall` (basándote en la clase `BouncingBall`, evidentemente). Las bolas de tipo `BoxBall` llevan siempre la misma velocidad (1 pixel cada vez), lo que sucede es que cuando golpean el una de las paredes del rectángulo rebotan y cambian de direccion. La posición inicial, el color y la direccion de cada bola debe fijarse de manera aleatoria.

2. Por cada funcionalidad atómica que desarrolles realiza un commit.

3. Cuando hayas terminado la actividad sube tu proyecto al repositorio de Github que habías creado en la actividad 0100.

 

### Variables de clase o estáticas

[Ver explicación en Youtube](http://youtu.be/Qi1ptpKHx2w)

<!--
- ¿Para que sirve la palabra clave static?
	- Para definir variables de clase o estáticas

- ¿Qué es una variable de clase?
	- Variables que pertenecen a la clase
	- No pertencen a ningun objeto en concreto
	- Hay una copia de la variable independientemente del numero de objetos
	- Diagrama	
	- Se dice que todos los objetos comparten esa variable
	- Se puede leer y modificar igual que si fuera un atributo normal
-->


### Constantes

[Ver explicación en Youtube](http://youtu.be/p4M68fEQrTY)

<!--
- ¿Qué es una constante?
	- Similar a un atributo
	- No pueden variar su valor
	- Palabra reservada final
	- Mayúsculas
	- Publicas
	- Si las llamamos desde fuera de la clase, usar nombre de clase
-->


### Actividad 0102

1. Localiza la definición de una constante en alguna de las clases del repositorio `bouncing-ball` de mi página de GitHub. ¿Qué representa el valor de esa constante?

2. Localiza la definición de dos constantes en alguna de las clases del repositorio `scribble` de mi página de GitHub. ¿Qué representan los valores de esas constantes?

3. Localiza el uso de una constante en el constructor de la clase `Pen` del repositorio `scribble` de mi página de GitHub.

4. Localiza las constantes existentes en la clase `LogEntry` del repositorio `weblog-analyzer` de mi página de GitHub. ¿Para que se utilizan dichas variables? Si Supón que ya no es necesario para nuestros análisis almacenar en el array `dataValues` el valor del año. ¿Habría que cambiar muchas cosas para que la clase siguiera funcionando si ahora el valor del mes queda en 0, en del día en 1, etc.? ¿Y si no se hubieran utilizado constantes?



### Actividad 0103

1. Escribe en un editor de texto 3 líneas en las que declares:
	- Una variable de clase pública constante que represente la altura máxima y que se fije al valor `0.001`.
	- Una variable de clase privada constante que represente el precio minimo y que este fijada a `4000`.
	- Una variable de clase publica constante de tipo char que sea usada para indicar que el comando de ayuda es `'h'`.



### Actividad 0104

1. Hay un rumor en Internet que dice que George Lucas, el director de la saga de películas "Star Wars", utilizaba una misma formula para crear los nombres de los personajes de dichas películas (Obiwan Kenobi, Jarjar Binks). La fórmula era la siguiente:

	1. Tu nombre en la película sería:

		1. Tomando las tres primeras letras de tu primer apellido real
		2. Añadiendo las tres primeras letras de tu nombre real

	2. Tu apellido en la película sería:

		1. Tomando las dos primeras letras del primer apellido real de tu madre
		2. Añadiendo las 3 primeras letras del nombre de la ciudad donde naciste

2. Se pide que crees en BlueJ un nuevo proyecto denominado `star-wars`. Crea una clase llamada `NameGenerator` e implementa un método llamado `generateStarWarsName` que genere un nombre para la película siguiendo el método descrito en el punto 1 tomando los datos necesarios como parámetros.

3. Testea el método, realiza un commit y súbelo a tu página de GitHub.



### Actividad 0105

1. El siguiente método intenta imprimir por pantalla en mayúsculas la cadena recibida como parámetro. Sin embargo no funciona. Investiga por qué no funciona y corrigelo en tu cuaderno:

	```
	public void printUpper(String s)
	{
		s.toUpperCase();
		System.out.println(s);
	}
	```


### Introducción al diseño de clases

[Ver explicación en Youtube](http://youtu.be/E0lg9DqObR0)

<!--
- Una aplicacion que funciona no siempre es una aplicacion bien diseñada
- Nuestro objetivo es diseñar buenas clases
- ¿Problemas de una aplicacion mal diseñada?
    - Mantenimiento mas complicado cuando queremos: 
        - Añadir funcionalidad
        - Corregir bugs
    - El mantenimiento es a largo plazo
        - Ejemplo: Windows
    - En aplicaciones grandes se nota mas
- Un buen diseño no depende de la dificultad del problema a resolver
- Un buen diseño depende de las decisiones del programador
-->


### Actividad 0106

1. Clona de mi página de GitHub el proyecto `zuul-bad` y ábrelo con BlueJ.

2. Este proyecto es un framework sencillo para un juego de aventuras. En esta versión solo disponemos de varias habitaciones y la posibilidad de que el jugador se desplace andando entre ellas. Para iniciar la aplicación crea un objeto de la clase `Game` e invoca su método `play`. Explora el funcionamiento de la aplicación de manera que seas capaz de responder a las siguientes preguntas:

	1. ¿Qué comandos acepta el juego en este momento?

	2. ¿Qué hace cada comando?

	3. ¿Cuántas habitaciones hay en el juego?

	4. Dibuja un mapa con las habitaciones existentes en este momento.

3. Este proyecto contiene en su nombre la palabra `bad` porque en la implementación de las clases se han cometido varios errores de diseño. No obstante, intenta descubrir para que sirve cada clase mirando en el código fuente de cada una de ellas. Probablemente no comprenderás todas las líneas del código fuente pero aún así deberías ser capaz de entender el propósito de las clases ya que, a menudo, leyendo los comentarios y las cabeceras de los métodos basta para hacerse una idea. De hecho, en este proyecto, aunque las clases están mal diseñadas, la documentación de las mismas es buena, lo que pone de manifiesto que un buen o mal diseño no depende de como se vea el código de una clase.



### Introducción al acoplamiento y la cohesión

[Ver explicación en Youtube](http://youtu.be/sOAFiBrIkZ8)

<!--
- ¿Como medimos la ideonidad del diseño?
    - El grado de acoplamiento y de cohesión define lo bueno o malo del diseño
- ¿Qué es el acoplamiento?
    - Se refiere a si las clases están muy interconectadas o no
    - Buscamos bajo acoplamiento
    - Cuanto mas alto el acoplamiento, mas dificil es hacer cambios
    - Si el acoplamiento es alto, un cambio en una clase conlleva cambios en otras
    - Es dificil saber donde hace falta cambios despues de un cambio
    - Con bajo acoplamiento, un cambio en una clase no repercute en otras
¿Qué es la cohesión?
    - Define si nuestras clases o metodos tienen un unico proposito
    - Buscamos que cada metodo haga una única cosa: alta cohesión
    - Asi podemos reutilizar métodos y clases en otros contextos
-->



### Actividad 0107

1. A partir del código de la actividad 0106 diseña en papel un escenario propio de un juego. Ejemplos de escenarios podrían ser los siguientes. Elige uno de ellos o piensa uno por tí mismo. En cualquier caso el juego debe tener un objetivon que haga que el jugador gane o pierda. 

	1. El jugador es glóbulo blanco viajando por el cuerpo humano en busca de un virus al que atacar.

	2. El jugador es una persona perdida en un centro comercial y debe encontrar la salida del mismo.

	3. El jugador es un topo que está en su madriguera y no recuerda donde tiene almacenadas las reservas de comida.

	4. El jugador es un héroe que está en una caverna en busca de un monstruo al que derrotar.

	5. El jugador es un desactivador de bombas y está en un edificio buscando una bomba antes de que explote.

2. Dibuja en tu cuaderno un mapa del juego que has pensado en el punto anterior. 

3. Modifica el método `createRooms` de la clase `Game` para recrear las localizaciones de tu juego.

4. Comprueba que el personaje puede desplazarse entre ellas y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0107">
Mostrar solucion
</button>
<div id="0107" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/Y-L2oKbAiNg)

</div>



### Repetición de código

[Ver explicación en Youtube](http://youtu.be/SBkyofBiR6E)

<!--
- La repeticion de código implica mal diseño
- Hay que evitarlo
- Un cambio supone modificar todas las ocurrencias
- Implica mas trabajo y mas posibilidad de errores
- La repeticion de código es síntoma de baja cohesion
- Metodos printWelcome y goRoom la presentan
- Traducir algo para demostrar el bug que entra
- ¿Como solucionarlo?
- No se pueden invocar entre ellos por la baja cohesion
- Codificar en un nuevo metodo el codigo repetido
-->


### Actividad 0108

1. A partir del código de la actividad 0107, resuelve la repetición de código existente en los metodos `printWelcome` y `goRoom` implementando un nuevo método llamado `printLocationInfo` que no lleve parámetros y que sea privado.

2. Testea los cambios y haz un commit.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0108">
Mostrar solucion
</button>
<div id="0108" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/hcoMgZl12iM)

</div>


### Actividad 0109

1. Clona de mi página de GitHub el repositorio `cities-visited` y ábrelo con BlueJ.

2. ¿Consideras que el acoplamiento entre la clase `VisitedCities` y las clases `String` y `ArrayList` es alto o es bajo?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0109">
Mostrar solucion
</button>
<div id="0109" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/70rLuGytmpY)

</div>


### Actividad 0110

1. En esta actividad trabajaremos a partir del código de la actividad 0108. 

2. Modifica el mapa que realizaste en la actividad 0107 de forma que ciertas localizaciones tengan una salida en dirección 	sureste.

3. Modifica la clase `Room` para que las localizaciones tengan la posibilidad de tener salida hacia el sureste.

4. ¿Hace falta hacer alguna modificación fuera de la clase `Room` para que el programa funcione correctamente? ¿Dónde? Llévalas a cabo.

4. Testea los cambios y haz un commit.

5. A la vista de la labores que has realizado en este ejercicio, ¿cómo crees que es el acoplamiento existente entre las clases `Game` y `Room`?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0110">
Mostrar solucion
</button>
<div id="0110" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/pqZN7Q1qS0c)

</div>




### Actividad 0111 

1. En esta actividad trabajaremos a partir del código de la actividad 0110.

2. Modifica la clase `Room` para que, basándonos en el principio del encapsulamiento, los atributos de dicha clase sean privados y el programa siga funcionando correctamente. Para ello añade un método denominado `getExit` que tome como parámetro una cadena que represente una dirección y devuelva el objeto de la clase `Room` asociado a esa salida o `null` si no hay salida.

3. Simplifica el siguiente código del método `goRoom` para que siga funcionando correctamente usando una unica línea de código:

	```
    // Try to leave current room.
    Room nextRoom = null;
    if(direction.equals("north")) {
        nextRoom = currentRoom.northExit;
    }
    if(direction.equals("east")) {
        nextRoom = currentRoom.eastExit;
    }
    if(direction.equals("south")) {
        nextRoom = currentRoom.southExit;
    }
    if(direction.equals("west")) {
        nextRoom = currentRoom.westExit;
    }	
    ```

4. Añade a la clase `Room` un método con la siguiente cabecera:

	```
	/**
	 * Return a description of the room's exits.
	 * For example: "Exits: north east west"
	 *
	 * @ return A description of the available exits.
	 */
	public String getExitString()
	```

5. Invoca el nuevo método en el método `printLocationInfo` de la clase `Game`.

6. Testea los cambios y haz un commit con el mensaje "Refactorizada la clase Room"

7. Modifica el proyecto para que el jugador pueda moverse también en dirección noroeste.

8. Testea los cambios y haz un commit.

8. ¿El acoplamiento entre las clases `Room` y `Game` se ha reducido o ha aumentado tras los cambios efectuados en los puntos 2, 3, 4 y 5?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0111">
Mostrar solucion
</button>
<div id="0111" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/iUSkit4wFmA)

</div>



### Actividad 0112

1. En esta actividad trabajaremos a partir del código de la actividad 0111.

2. Implementa el uso de un `HashMap` cuyas claves sean objetos `String` y sus valores objetos `Room` para representar dentro de la clase `Room` las salidas en vez de usar, como hasta ahora, un atributo por cada salida. Este cambio debe realizarse sin modificar la interfaz de la clase `Room` (es decir, no se pueden cambiar las cabeceras de los métodos de dicha clase); solo se puede cambiar la implementación de la clase.

3. Testea los cambios comprobando que el programa sigue funcionando correctamente y haz un commit.

4. A la vista de cómo has llevado a cabo los cambios, ¿cómo consideras que es el acoplamiento entre las clases `Room` y `Game`?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0112">
Mostrar solucion
</button>
<div id="0112" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/UE3PZpDYUB4)

</div>


### Actividad 0113

1. En esta actividad trabajaremos a partir del código de la actividad 0112.

2. Realiza los cambios necesarios en la clase `Room` y en la clase `Game` para que podamos almacenar cualquier dirección de salida que deseemos dentro de una localizacion. Estos cambios pueden (deben) incluir cambios en la interfaz de la clase `Room`.

3. Testea los cambios y haz un commit.

4. ¿Por qué aunque nos hayamos visto obligados a realizar cambios en la clase `Game` podemos decir que el acoplamiento entre las clases `Room` y `Game` sigue siendo bajo?


<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0113_1">
Mostrar pista 1
</button>
<div id="0113_1" class="collapse">
Elimina el método `setExits` de la clase `Room` y añade otro método que permita definir las salidas de forma individual. Usa este último método tantas veces como salidas quieras definir para una localización dentro del método `createRooms` de la clase `Game`.
</div>

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0113_2">
Mostrar pista 2
</button>
<div id="0113_2" class="collapse">
El método que permite definir las salidas de forma individual tendría la siguiente cabecera:

```
/**
 * Define an exit from this room.
 * @param direction The direction of the exit.
 * @param neighbor The room in the given direction.
 */
public void setExit(String direction, Room neighbor)
```
</div>

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0113">
Mostrar solucion
</button>
<div id="0113" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/Q9avK8OEdWo)

</div>



### Actividad 0114

1. En esta actividad trabajaremos a partir del código de la actividad 0113.

2. Implementa en la clase `Room` un método con la siguiente cabecera:

	```
	/**
	 * Return a long description of this room, of the form:
	 *     You are in the 'name of room'
	 *     Exits: north west southwest
	 * @return A description of the room, including exits.
	 */
	public String getLongDescription()
	```

3. Modifica el método `printInfoLocation` de la clase `Game` para que haga uso de el modo añadido en el paso anterior en vez de la implementación actual.

4. Testea los cambios y haz un commit con el mensaje "Creado el metodo getLongDescription en la clase Room para aplicar reponsability-driven design".

5. ¿Ves que exista alguna ventaja por el cambio realizado en el caso de que en el futuro añadieramos más detalles a nuestros objetos `Room` como por ejemplo monstruos, otros items, etc.?

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0114">
Mostrar solucion
</button>
<div id="0114" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/J5OJ4fDj65w)

</div>


<!--

En este video vamos a ver la solucion a la actividad 0114. Antes de nada es necesario hablar un poco sobre responsibility driven desing.

Responsibility driven desing es un principio que expresa la idea de que cada clase debe ser la responsable de manejar sus propios datos. 

En muchas ocasiones vamos a necesitar añadir funcionalidades a nuestros programas y es entonces cuando tenemos que preguntarnos en qué clase debemos añadir el método que consigue implementar la nueva funcionalidad. La respuesta siguiendo el principio de responsibilty driven design es que la clase que es responsable de almacenar un dato debe ser también la responsable de manipularlo.

En general, cuanto mejor apliquemos este principio menor será el grado de acoplamiento entre clases. Y cuanto menor sea el grado de acoplamiento, más facil resultará hacer una modificación a nuestro programa.

Si nos fijamos en la clase Game, en el método printLocationInfo, vemos que la clase Game sabe que la información que almacena un objeto Room es una descripcion de la localizacion y las salidas disponibles.

El problema es que si decidimos hacer cambios en la clase Room, como por ejemplo añadir items, añadir personajes o añadir monstruos, todo lo que le añadamos debería aparecer en la descripción de la habitación. Y entonces necesitaríamos, ademas de cambiar la clase Room cambiar también el metodo printLOcationInfo de la clase Game.

Y hay que recordar que nuestro objetivo es reducir el acoplamiento al máximo, de forma que si hacemos cambios en la clase Room no nos veamos obligados a hacerlos también en la clase Game.

Así que siguiendo el principio de responsibilty driven desing, dado que la clase Room es la que almacena los datos referidos a una localización también debería ser esa la clase donde se cree la descripción de la localización.

Para ello añadimos en la clase Room el siguiente método tal y como nos pide el enunciado de la actividad:


/**
 * Return a long description of this room, of the form:
 *     You are in the 'name of room'
 *     Exits: north west southwest
 * @return A description of the room, including exits.
 */
public String getLongDescription()
{
	return "You are " + description + ".\n" + getExitString();
}


Y ahora en la clase Game dejamos el método printLocationInfo con el siguiente contenido:

System.out.println(currentRoom.getLongDescription());


Lo que ahora llamamos la descripcion larga de una localización incluye ahora la cadena conteniendo la descripción de la localización y la información sobre las salidas. En el futuro podemos hacer que incluya cualquier otra cosa relativa a la localización pero lo bueno es que ya solo tendremos que cambiar unicamente la clase Room.

Ahora probamos que funciona ::::::

Y finalmente ya solo nos queda hacer el commit:

"Creado el metodo getLongDescription en la clase Room para aplicar reponsability-driven design"

-->


### Actividad 0115

1. En esta actividad trabajaremos a partir del código de la actividad 0114.

2. Implementa los cambios necesarios en las clases `CommandWords` y en `Game` para poder añadir el comando `look`. Este comando se utiliza para ver lo que hay en una localización y, únicamente, hace uso del método `getLongDescription` de la clase `Room`. Es un comando que puede resultar util cuando el jugador se ha desplazado a una localización, ha introducido varios comandos en ella y la descripción de la localización ha quedado tan arriba que está fuera de la vista en la consola.

3. Testea los cambios y haz un commit.

4. ¿Existe algún cambio de todos los que has realizado en esta actividad que resulte probable olvidarse de hacer cada vez que implementemos un nuevo comando?


<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0115">
Mostrar solucion
</button>
<div id="0115" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/NN-9pnL-jzA)

</div>

<!--

En este video vamos a ver la solucion a la actividad 0115.

Cuando programamos debemos siempre hacer un buen diseño de nuestra aplicación. Si esta bien diseñada, cuando tengamos que hacer algún cambio será fácil localizar qué puntos de la aplicación han de ser modificados para llevar a cabo correctamente dicho cambio.

Lo ideal sería que cuando hagamos un cambio solo tengamos que tocar una clase. Si no es posible y hay que modificar otras clases lo ideal sería que los puntos donde hay que cambiar esas clases fueran fáciles de detectar.

Si seguimos el principio de responsability driven design, y conseguimos un bajo acoplamiento y una alta cohesión probablemente consigamos que estos cambios en otras clases sean obvios.

Hemos visto cuando empezamos con nuestro juego que utilizar atributos públicos es siempre una mala idea. Sin embargo hay algo aun peor, que es lo que llamamos el acoplamiento implícito. 

El acoplamiento implicito se da cuando una clase depende de la informacion interna de otra pero esta dependencia no es facil de ver a simple vista. 

Cuando usamos atributos publicos ya sabemos que estamos aumentando el acoplamiento entre clases pero al menos esta situacion se ve directamente. Si yo cambio esos atributos públicos en la clase a la que pertenecen y luego no reflejo ese cambio en las otras clases que los usan la aplicación no va a compilar. Eso fue lo que nos paso en una actividad pasada.

Sin embargo, en el caso del acoplamiento implicito, es posible que cuando cambiemos algo en una clase no nos demos cuenta de todos los cambios que hay que hacer en el resto de clases.

Para añadir el comando look lo primero es cambiar la clase CommandWords. Concretamente debemos añadir al array de comandos llamado validCommands la cadena "look":


private static final String validCommands[] = {
"go", "quit", "help", "look"
};


La clase CommandWords es un ejemplo de alta cohesión. En vez de definir la lista de comandos en la clase Parser, que se podía haber hecho, se ha creado una clase aparte solo para eso. Eso nos permite que encontrar el lugar donde añadir nuevos comandos sea fácil.

Si probamos el programa ahora mismo, vemos que el comando no funciona.

::: Probar a ejecutar look :::

No ocurre absolutamente nada. Fijaros que no sale el mensaje que el juego muestra cuando no entiende el comando. 

::: Probar a meter algo diferente :::

Eso prueba que el programa esta reconociendo look como un comando válido, pero no se esta llevando a cabo ninguna acción para ese comando.

Para arreglarlo necesitamos modificar el metodo processCommand de la clase Game.

Y antes de ello debemos añadir un metodo look a esa clase:

/** 
 * Print the room's long description 
 */
public void look() 
{
	System.out.println(currentRoom.getLongDescription());
}

Ahora modificamos la instruccion condicional de processCommand de forma que se invoque el metodo look cuando se introduzca el comando look:


if(commandWord.equals("help")) {
	printHelp();
}
else if(commandWord.equals("go")) {
	goRoom(command);
}
else if(commandWord.equals("look")) {
	look();
}
else if(commandWord.equals("quit")) {
	wantToQuit = quit(command);
}

::: Probamos el juego :::

Podríamos decir que el acoplamiento entre las clases Game, Parser y CommandWords parece que es bastante bajo ya que ha sido facil implementar la nueva funcionalidad.

El problema es que existe entre estas clases un acoplamiento implicito que no hemos detectado y que se ve cuando usamos el comando help.

::: Probar el comando help :::

Vemos que el nuevo comando no se muestra en la ayuda.

Este fallo parece facil de solucionar porque simplemente tenemos que añadir el texto look en el metodo printHelp de la clase Game lo cual se hace rapido y facil. Pero el problema real es que es posible que este cambio que es necesario hacer se nos pasara por alto y nunca lo hicieramos, quedando el programa con un funcionamiento inconsistente. 

Incluso habiendo detectado que teníamos que hacer ese cambio, es muy posible que en el futuro se nos olvide hacerlo cuando añadamos un nuevo comando.

Vemos que el programa compila y en principio funciona bien pero tiene un bug. Es un ejemplo de los problemas que da el acoplamiento implicito.

-->






### Actividad 0116

1. En esta actividad trabajaremos a partir del código de la actividad 0115, con el objetivo de reducir el acoplamiento existente entre las clases `Game` y `CommandWords` detectado en el método `printHelp` de la primera.

2. Aplicando el principio de responsability-driven design, implementa en la clase `CommandWords` un método con la siguiente cabecera que muestre en la terminal todos los comandos disponibles:

	```
	/**
	 * Print all valid commands to System.out
	 */
	public void showAll()
	```

3. El problema es que en la clase `Game` no tenemos ningún atributo de tipo `CommandWords`. Existen dos soluciones: __(A)__ implementar un método en la clase `Parser` que nos devuelva el atributo `commands` de dicha clase, que es de tipo `CommandWords` e invocar dicho método desde la clase `Game` o __(B)__ implementar un método en la clase `Parser` que consiga imprimir por pantalla todos los comandos disponibles e invocarlo desde la clase `Game`.

4. Implementa la primera opción, testeala y haz un commit. El texto del mensaje del commit debe empezar por "0116 Opcion A:".

5. Cambia ahora a la implementación sugerida en la opción B, testéala y haz un commit. El texto del mensaje del commit debe empezar con "0116 Opcion B:".

6. ¿Hemos reducido el acoplamiento entre las clases `Game` y `CommandWords` o lo hemos aumentado?

7. ¿Cuál crees que es mejor opción desde el punto de vista de un buen diseño: la opción A o la opción B? Justifica razonadamente tu respuesta.

8. Implementa un nuevo comando en el juego denominado `eat`. Para hacerlo sencillo, cuando el usuario invoque este comando debe mostrarse por pantalla el mensaje "You have eaten now and you are not hungry any more".

9. Testea que el nuevo comando y el programa entero funciona correctamente y haz un commit. El texto del mensaje del commit debe empezar por "0116 Final:".

10. Crea un repositorio en tu página de GitHub y haz un push de este proyecto en dicho repositorio.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0116">
Mostrar solucion
</button>
<div id="0116" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/Pt7imt9G7i8)

</div>


<!--

En este video vamos ver la solucion a la actividad 0116.

Como dice el enunciado, si aplicamos el principio de responsibility driven design tenemos que si la clase CommandWords es la responsable de almacenar la lista de comandos también debería ser la responsable de imprimirlos por pantalla.

Así que vamos a añadir el método necesario para ello:

/**
* Print all valid commands to System.out.
*/
public void showAll()
{
	for(String command : validCommands) {
		System.out.print(command + " ");
	}
	System.out.println();
}

La idea ahora es que el metodo printHelp, en vez de imprimir una cadena fija con el listado de comandos invoque el metodo showAll de un objeto de tipo CommandWords. De esta forma hacemos que cuando añadamos un comando no haya que tocar la clase Game.

El problema es que los objetos de la clase Game no tienen ningun atributo de la clase CommandWords. De hecho, si nos fijamos en la pantalla principal de BlueJ vemos que la clase Game no tiene ni siquiera una flecha hacia la clase CommandWords. Esto indica que la clase Game ni siquiera sabe de la existencia de la clase CommandWords. Lo que tenemos en realidad es que la clase Game tiene un atributo de la clase Parser y esta clase tiene un atributo de la clase CommandWords.

Conforme a la opción A del enunciado, una solucion es añadir un metodo a la clase Parser que nos devuelva el atributo de tipo CommandWords de dicha clase. Este metodo lo invocamos desde Game y ya tenemos un objeto de la clase CommandWords sobre el que invocar el metodo showAll.

Vamos a implementarlo. Añadimos en la clase Parser:

/** 
 * Return the field commands 
 *
 * @return The field commands
 */
public CommandWords getCommands()
{
	return command;
}

Y añadimos en el metodo printHelp de la clase Game:

parser.getCommands().showAll();

Lo testeamos.

::: Probar que funciona :::

Y hacemos un commit:

"0116 Opcion A: los comandos que imprime ahora la ayuda son los definidos en CommandWords"

Esta opcion, que como vemos funcionar funciona, tiene el problema de que aumenta el acoplamiento entre clases de nuestra aplicacion. Ahora, la clase Game depende también de la clase CommandWords, cosa que antes no pasaba.

De hecho, en la pantalla principal de BlueJ vemos que ha aparecido una flecha entre Game y CommandWords. Esta flecha es una primera indicacion de que el acoplamiento ha aumentado. En general podemos pensar que cuantas mas flechas haya en nuestra aplicacion mas acoplamiento habrá.

Con la opcion B, en cambio, la clase Game va a seguir sin conocer ni depender de la clase CommandWords. Para la clase Game solo va a existir un metodo en la clase Parser al que llamar. A la clase Game no le interesa saber que hace la clase Parser para conseguir imprimir los comandos. Podemos decir que el uso de la clase CommandWords por parte de la clase Parser en esta segunda opcion es parte de la implementacion de la clase Parser y para la clase Game es algo que ni siquiera conocer.


En la clase Parser:

/**
 * Print out a list of valid command words
 */
public void showCommands()
{
	commands.showAll();
}


Y en el metodo printHelp de la clase Game:

parser.showCommands();


Probamos que todo funcione.

::: Probar el juego :::


Y hacemos un commit:

"0116 Opcion B: los comandos que imprime ahora la ayuda son los definidos en CommandWords con menos acoplamiento"


Ahora debemos implementar el comando eat. Para ello modificamos la clase CommandsWord:

private static final String validCommands[] = {
"go", "quit", "help", "look", "eat"
};


Y luego, en la clase Game, añadimos el metodo eat:

/**
 * The player eats
 */
private void eat()
{
	System.out.println("You have eaten now and you are not hungry any more".);
}


Finalmente, en el metodo processCommand de la clase Game, modificamos la instruccion condicional:

if(commandWord.equals("help")) {
	printHelp();
}
else if(commandWord.equals("go")) {
	goRoom(command);
}
else if(commandWord.equals("look")) {
	look();
}
else if(commandWord.equals("eat")) {
	eat();
}
else if(commandWord.equals("quit")) {
	wantToQuit = quit(command);
}


::: Probar el juego :::

Para terminar, hacemos un commit:

"0116 Final: añadido comando eat"


-->



### Actividad 0117

1. En esta actividad trabajaremos a partir del código de la actividad 0116.

2. Queremos ampliar las funcionalidades de nuestro juego incluyendo la posibilidad de que cada localización contenga un objeto (_item_). Cada objeto se caracteriza por una descripción y un peso en kilogramos (que tal vez usemos en actividades posteriores para saber si el jugador puede cargar con dicho objeto o no). Para implementar esta funcionalidad añade ese par de atributos a la clase `Room` y realiza las modificaciones necesarias para que cuando se crea la localización también se cree su objeto asociado y para que cuando un jugador entre en una localización o utilice el comando `look` se le informe de que objeto hay en ella y cuanto pesa.

3. Testea los cambios y haz un commit. El mensaje del commit debe empezar por "0117 Final:".

4. Actualiza tu repositorio en GitHub.

5. ¿Detectas algún problema con esta implementación de cara a mejorar la funcionalidad de que haya objetos en las localizaciones?

6. ¿Cómo crees que es la cohesión de la clase `Room`? Justifica razonadamente la respuesta.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0117">
Mostrar solucion
</button>
<div id="0117" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/brQnl1z23ww)

</div>

<!--

En este video vamos a ver a solucion de la actividad 0117.

Tal y como nos dice el enunciado vamos a añadir a la clase Room dos atributos: la descripcion del item que contiene la localizacion y el peso del mismo. 

private String itemDescription;
private float itemWeight;

Esos atributos, conforme el enunciado, van a ser inicializados en el contructor como parametros:

public Room(String description, String itemDescription, float itemWeight) 
{
    this.description = description;
    exits = new HashMap<>();
    this.itemDescription = itemDescription;
    this.itemWeight = itemWeight;
}


Y tenemos que modificar también el metodo getLongDescription:

String longDescription = "You are " + description + ".\n" + getExitString();
longDescription += "There is 1 item:\n";
longDescription += "- " + itemDescription + " (" + itemWeight + "kg.)";


Como ha cambiado la interfaz de la clase Room al modificar la cabecera del constructor, es seguro que en la clase Game tendremos que hacer cambios. En concreto en el metodo createRooms debemos modificar todas aquellas lineas que invocan a dicho constructor:

        galicia = new Room("el reino de Galicia, "Una espada gaelica", 3.5);
        leon = new Room("el reino de León", "El Santo Grial", 1.4);
        castilla = new Room("el reino de Castilla", "Un cuchillo afilado", 0.5);
        aragon = new Room("el reino de Aragon", "Una carreta", 35.5);
        granada = new Room("el reino de Granada", "Una pocima contra el dolor de cabeza", 0.6);
        portugal = new Room("el reino de Portugal", "Una armadura", 20.2);


Ahora solo queda probar el programa.

Y hacer un commit:

"0117 Final: añadida la existencia de un item por localizacion" 


Un problema con esta implementacion de cara a mejorar la funcionalidad de que haya objetos en las localizaciones es que si queremos que haya más de un objeto no lo tenemos fácil de implementar.

Ya sabemos que la cohesion es la idea de que una clase debe representar una única entidad y un metodo debe de ser responsable de hacer una única cosa.

Resulta que con esta modificacion la clase Room esta representando dos cosas diferentes: una localizacion y un item. Por tanto, la cohesión de dicha clase es evidente que es baja.


-->



### Actividad 0118

1. En esta actividad trabajaremos a partir del código de la actividad 0117.

2. Implementa la posibilidad de que una localización puede tener ahora de 0 a un número no determinado de objetos. Eres libre de crear alguna clase nueva si consideras que mejora el diseño y aumenta la cohesión de la clase `Room`. Lo que si es necesario es que la clase `Room` disponga de un método denominado `addItem` que permita añadir un objeto a dicha localización.

3. Testea los cambios y haz un commit. El mensaje del commit debe empezar por el texto "0118 Final:".

4. Actualiza tu repositorio en GitHub.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0118">
Mostrar solucion
</button>
<div id="0118" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/2x7qnP7Urow)

</div>

<!--

Clase Item:

/**
 * An item contained in a room
 * 
 * @author Miguel Bayon
 * @version 1.0
 */
public class Item
{
    private String description;
    private double weight;

    /**
     * Constructor for objects of class Item
     * 
     * @param description The item's description
     * @param weight The item's weight
     */
    public Item(String description, double weight)
    {   
        this.description = description;
        this.weight = weight;
    }

    /**
     * Get the long description of item
     * 
     * @return     The long description of item
     */
    public String getLongDescription()
    {
        return description + " (" + weight + " kg.)";
    }
     
}


Clase Room:

import java.util.HashMap;
import java.util.Set;
import java.util.ArrayList;

/**
 * Class Room - a room in an adventure game.
 *
 * This class is part of the "World of Zuul" application. 
 * "World of Zuul" is a very simple, text based adventure game.  
 *
 * A "Room" represents one location in the scenery of the game.  It is 
 * connected to other rooms via exits.  The exits are labelled north, 
 * east, south, west.  For each direction, the room stores a reference
 * to the neighboring room, or null if there is no exit in that direction.
 * 
 * @author  Michael Kölling and David J. Barnes
 * @version 2011.07.31
 */
public class Room 
{
    private String description;   
    private HashMap<String, Room> exits; 
    private ArrayList<Item> items;

    /**
     * Create a room described "description". Initially, it has
     * no exits. "description" is something like "a kitchen" or
     * "an open court yard".
     * @param description The room's description.
     */
    public Room(String description) 
    {
        this.description = description;
        exits = new HashMap<>();
        items = new ArrayList<>();
    }

    public void setExit(String direction, Room nextRoom)
    {
        exits.put(direction, nextRoom);
    }

    /**
     * @return The description of the room.
     */
    public String getDescription()
    {
        return description;
    }

    public Room getExit(String direction) 
    {               
        return exits.get(direction);
    }

    /**
     * Return a description of the room's exits.
     * For example: "Exits: north east west"
     *
     * @ return A description of the available exits.
     */
    public String getExitString()    
    {
        Set<String> namesOfDirections = exits.keySet();
        String exitsDescription = "Exit ";

        for (String direction : namesOfDirections) {
            exitsDescription += direction + " ";
        }

        return exitsDescription;
    }

    /**
     * Return a long description of this room, of the form:
     *     You are in the 'name of room'
     *     Exits: north west southwest
     * @return A description of the room, including exits.
     */
    public String getLongDescription()
    {
        String longDescription = "You are " + description + ".\n" + getExitString() + "\n";
        longDescription += "There are " + items.size() + " items:\n";
        for (Item item : items) {
            longDescription += "- " + item.getLongDescription() + "\n";
        }
        return longDescription;
    }

    /**
     * Add an item to the room
     */
    public void addItem(Item item)
    {
        items.add(item);
    }
    
}


Clase Game:

        galicia = new Room("el reino de Galicia");
        leon = new Room("el reino de León");
        castilla = new Room("el reino de Castilla");
        aragon = new Room("el reino de Aragon");
        granada = new Room("el reino de Granada");
        portugal = new Room("el reino de Portugal");         



        galicia.addItem(new Item("Una espada gaelica", 3.5));
        galicia.addItem(new Item("Un tonel de vino", 10.2));
        
        leon.addItem(new Item("El Santo Grial", 1.4));
        
        castilla.addItem(new Item("Un cuchillo afilado", 0.5));
        castilla.addItem(new Item("Un cofre de oro", 3.0));
        castilla.addItem(new Item("Un baul de madera", 24.8));
        
        aragon.addItem(new Item("Una carreta", 35.5));
        
        granada.addItem(new Item("Una pocima contra el dolor de cabeza", 0.6));
        
        portugal.addItem(new Item("Una armadura", 20.2));


Commit:

"0118 Final: añadida la posibilidad de que haya mas de un item por localizacion"

-->


### Actividad 0119

1. En esta actividad trabajaremos a partir del código de la actividad 0118.

2. Implementa un comando denominado `back`. Este comando se ejecuta sin indicar una segunda palabra y permite al jugador volver a la localización previa.

3. Testea los cambios y haz un commit. El mensaje del commit debe empezar por "0119:".

4. ¿Es posible ejecutar dos veces seguidas el comando `back`? 

5. Implementa la posibilidad de que se pueda utilizar el comando `back` todas las veces seguidas que se quiera hasta llegar a la primera localización de donde partió el jugador. Para ello utiliza la clase `Stack`. Debes investigar en Internet que representa y cómo se puede utilizar.

6. Testea los cambios y haz un commit. El mensaje del commit debe empezar por "0119 Final:".

7. Actualiza tu repositorio en GitHub.

<button type="button" class="btn btn-danger" data-toggle="collapse" data-target="#0119">
Mostrar solucion
</button>
<div id="0119" class="collapse">
[Ver vídeo en Youtube](http://youtu.be/4eyVDJjVPrA)

</div>


<!--

Problemas:

1. Se puede ejecutar dos veces pero no funciona
2. Si se ejecuta de inicio peta


-->




### Ramas en git

[Ver explicación en Youtube](http://youtu.be/a59Apqn1csE)



### Refactorización

[Ver explicación en Youtube](http://youtu.be/H1jkhnroGqA)

<!--
Cuando diseñamos una aplicación debemos pensar a largo plazo. Debemos anticipar posibles cambios que en el futuro tal vez queramos introducir en ese proyecto.

El objetivo es crear una aplicación donde la cohesión de los métodos y de las clases sea alta y donde el acoplamiento entre las clases sea bajo. Si conseguimos esto, probablemente las modificaciones futuras del proyecto sean más fáciles de llevar a cabo.

El problema de todo esto es que muchas veces es imposible anticiparse a todos los cambios que se van a hacer a un programa o a todas las nuevas funcionalidades que se van a implementar.

Y aquí es donde entra la refactorización.

Refactorizar consiste básicamente en reestructurar los métodos y las clases de nuestra aplicación para conseguir mejorar el diseño del proyecto.

Tenemos que pensar que a lo largo del ciclo de vida de una aplicación se van añadiendo nuevas funcionalidades. Esto generalmente provoca que nuestros métodos y clases van haciendose cada vez más grandes.

Es tentador para un programador novato ir añadiendo código extra a los métodos y a las clases sin preocuparse de más. El problema es que hacer esto conlleva, generalmente, que el grado de cohesión desciende. Cuanto mas y mas código añadimos a un método o a una clase lo más problable es que llegue un punto en el que dicho método no representa una única actividad o que dicha clase no representa a na única entidad.

Cuando refactorizamos lo que hacemos es repensar el diseño actual de nuestra aplicación. Generalmente esto nos va a llevar a dividir en dos una clase o a dividir en dos o más métodos alguno de los métodos de nuestro proyecto. También a veces, aunque es menos común, refactorizar incluye reagrupar una serie de clases en una única clase o reagrupar una serie de métodos en un único método.

Cuando refactorizamos un programa lo que vamos a hacer generalmente es hacer una serie de cambios sobre algo que ya funciona. Y siempre que se cambia algo que ya funciona es comun cometer errores y hacer que deje de funcionar. Por tanto es muy importante proceder con mucho cuidado.

Antes de refactorizar tenemos que definir una serie de test y pasarlos sobre la versión actual del programa para comprobar que todo funciona correctamente. Cuando hayamos terminado de refactorizar lo que hacemos es volver a pasar los mismos test para estar seguros de que no hemos introducido ningún error en todo el proceso.

Tenemos que pensar que cuando refactorizamos lo que hacemos es mejorar la manera en que está estructurado el proyecto pero no tenemos que añadir ninguna funcionalidad nueva. Es decir, una vez refactorizado, el programa se tiene que comportar como lo hacía antes.

¿Que pasa si refactorizamos y a la vez introducimos nuevas funcionalidades? Si algo, por el motivo que sea, no funciona correctamente, nos va a ser mucho más complicado descubrir donde esta el error.

-->




### Actividad 0120

1. En esta actividad vamos a trabajar sobre el codigo de la actividad 0119.

2. El objetivo final de la actividad es añadir una nueva funcionalidad consistente en que __(1)__ el jugador puede coger items de la localización actual, __(2)__ teniendo en cuenta que cada objeto tiene un peso y el jugador solo puede transportar items sin sobrepasar un peso máximo, __(3)__ que algunos items no pueden ser cogidos y que __(4)__ el jugador puede dejar en la localización actual, de entre los items que transporta, el item que desee. Deben existir, por tanto, un par de nuevos comandos denominados `take` y `drop` para coger y soltar items y otro nuevo comando denominado `items` que nos muestre la información sobre todos los items que el jugador lleva consigo.

3. Piensa cómo deberías refactorizar tu proyecto para que una vez que añadamos luego todas estas nuevas funcionalidades el diseño de la aplicación no empeore. Básicamente la clave es añadir una nueva clase denominada `Player`. Escribe en tu cuaderno un resumen de dicha factorización: qué vas a reestructurar y por qué. No lleves a cabo ningún cambio en el código todavía.

4. ¿Qué test deberías pasarle a la aplicación tal y como está actualmente para comprobar que está funcionando correctamente y que nos sirvan de cara a comprobar que la refactorización se ha llevado a cabo de forma correcta? Escribe un resumen de los mismos en tu cuaderno.

5. Refactoriza el código fuente de la aplicación de forma que se introduzca en el proyecto la clase `Player`. No la fusiones hasta que el código de dicha rama haya pasado los test que ideaste en el punto 4. 

6. Implementa ahora las nuevas funcionalidades descritas en el punto 2. Utiliza una rama nueva para desarrollar todas las funcionalidades y fusionala con la rama principal cuando hayas terminado. En la nueva rama vete realizando tantos commit como creas necesario.

7. Actualiza tu repositorio de GitHub con los cambios efectuados.


<!--


### Tipos enum

¿Son clases?
¿Podemos crear objetos de tipo enum usando el constructor new?
¿Para qué vale el método que los tipos enum incorporan por defecto denominado values?

-->

### Actividad 0121

1. Investiga por Internet sobre los __tipos enum__. En concreto, averigua:

	1. ¿Como es la sintaxis que se debe usar para definir un tipo `enum`?
	2. ¿Qué representa un tipo `enum`?
	3. Un ejemplo de declaración de tipo `enum`
	4. Un ejemplo de uso de un tipo `enum`
	4. ¿Que diferencias tiene con las clases?
	5. ¿Podemos crear objetos de tipo `enum` usando el constructor `new`?
	6. ¿Para qué vale el método que los tipos enum incorporan por defecto denominado `values`?
	7. ¿Pueden tener atributos los objetos de un tipo `enum`? ¿Como podemos darles valores iniciales a esos atributos?
	8. ¿Por qué el constructor de un tipo `enum` no es `public`?



### Actividad 0122

1. En esta actividad vamos a partir del código de la actividad 0120. 

2. ¿En qué clases se requieren cambios para que el jugador pudiera jugar al juego introduciendo sus comandos en español?

2. Crea una nueva rama denominada `refactorizacion-independencia-lenguaje`. Vamos a intentar refactorizar a continuación el programa para que posteriormente seamos capaces de conseguir más fácilmente que el usuario escriba los comandos en español. 

3. Declara un tipo enum denominado `Option` que tenga tantos elementos como comandos hay en nuestro programa más uno adicional denominado `UNKNOWN`.

3. En la clase `CommandWords` sustituye el atributo array por un `HashMap` que enlace Strings con objetos de tipo `Option`. Inicializa ese hashmap en el constuctor enlazando cada palabra en ingles con el objeto correspondiente de tipo `Option`. Modifica el resto de métodos para que sean acordes con este cambio.

4. Añade a la clase `CommandWords` un metodo con la siguiente cabecera:

	```
    /**
     * Return the Option associated with a word.
     * @param commandWord The word to look up (as a string).
     * @return The Option correspondng to commandWord, or UNKNOWN
     *         if it is not a valid command word.
     */
    public Option getCommandWord(String commandWord)
    ```

5. Modifica donde sea preciso la clase `Command` para que el atributo `commandWord` sea de tipo `Option` en vez de una cadena. Date cuenta que ya no utilizamos `null` en el atributo `commandWord` para indicar que un comando no es valido.

6. Modifica la clase `Parser` para que compile teniendo en cuenta los cambios realizados anteriormente. Date cuenta que ahora el objeto `Command` que devuelve el método `getCommand` no tiene un `null` como primer atributo sino `UNKNOWN`.

7. Modifica la clase `Game` para que el método `processCommand` funcione con los cambios realizados anteriormente.

8. Testea la refactorización y haz un commit. Luego fusiona la rama con la principal. Finalmente, borra la rama `refactorizacion-independencia-lenguaje`.



### Actividad 0123

1. En esta actividad vamos a partir del código de la actividad 0122.

2. Realiza las modificaciones necesarias para que el jugador use comandos en español para jugar al juego.

3. Testea los cambios y haz un nuevo commit.

4. ¿En cuántas clases tuviste que hacer modificaciones para traducir los comandos al español? ¿En más o en menos que si no hubieramos refactorizado la aplicación en la actividad anterior?

5. Tu programa probablemente contiene ahora un bug asociado a la traducción de comandos que has realizado. ¿Eres capaz de descubrirlo? Solucionalo de forma que aunque luego tradujeramos los comandos del juego a otro idioma no tuvieramos que cambiar la clase `Game`.

6. Testea los cambios y haz un commit.

7. En la clase `Game` modifica el método `processCommand` para utilizar una estructura `switch` en vez del `if-else` que se utiliza para elegir el método a ejecutar en función del comando introducido.

8. Testea los cambios y haz un commit.

9. Actualiza tu repositorio en GitHUb.


<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0122">
Mostrar pista 
</button>
<div id="0122" class="collapse">
__Paso 5__. El bug consiste en que cuando se muestra el mensaje inicial se dice que el comando para conseguir ayuda es `help` cuando ahora en realidad es `ayuda`.
</div> 




### Actividad 0124

1. En esta actividad vamos a partir del código de la actividad 0123.

2. ¿En cuántas clases hay que hacer cambios actualmente si queremos añadir un nuevo comando?

3. Vamos a refactorizar nuevamente el código de la aplicación para conseguir reducir el numero de clases implicadas a la hora de añadir un nuevo comando. Para ello crea una nueva rama llamada `refactorizacion-option-autocontenida`. Hemos elegido ese nombre porque el objetivo de esta refactorización es que el tipo enum `Option` sea el que contenga también el `String` asociado a cada comando.

4. Realiza los cambios necesarios en `Option` para que cada elemento de la enumeración tenga una relación con el `String` correspondiente.

5. Modifica la clase `CommandWords` para que se adapte a los cambios introducidos en `Option`. No cambies nada de la interfaz de la clase, solo de su implementación.

6. Testea la refactorización y haz un commit. Luego fusiona la rama con la principal. Finalmente, borra la rama `refactorizacion-option-autocontenida`.

7. ¿En cuántas clases debes hacer cambios ahora si queremos añadir un nuevo comando?

8. Actualiza tu repositorio en GitHub.

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0124_1">
Mostrar pista 1
</button>
<div id="0124_1" class="collapse">
__Paso 4__. En el tipo enum `Option` debes añadir un atributo de tipo `String` que sea inicializado en el constructor del tipo enumerado. Además debes añadir un método getter para dicho atributo.
</div> 

<button type="button" class="btn btn-warning" data-toggle="collapse" data-target="#0124_2">
Mostrar pista 2
</button>
<div id="0124_2" class="collapse">
__Paso 5__. Puedes eliminar el atributo `validCommands` y hacer uso del método `values` del tipo enumerado `Option` para conseguir mantener la funcionalidad de los método existentes.
</div> 



### Actividad 0125

1. En esta actividad vamos a partir del código de la actividad 0124.

2. El objetivo de esta actividad es que implementes una nueva funcionalidad al juego a tu elección. Para ello es necesario que:

	1. Escribas una especificación lo más completa posible describiendo la nueva funcionalidad. Si no se te ocurre ninguna nueva funcionalidad echa un vistazo al final del enunciado de esta actividad.

	2. Pienses en cómo implementar la nueva funcionalidad de forma que el diseño de la aplicación sea el mejor posible, manteniendo bajo el acoplamiento y alta la cohesión.

	3. Mediante una nueva rama de git implementa la funcionalidad pensada, testeala y mezclala con la rama principal cuando estes seguro de que funciona correctamente.


__Posibles nuevas funcionalidades:__ 

* Añadir algún tipo de límite de tiempo al juego. Si no se realiza una determinada tarea dentro de ese tiempo el personaje pierde la partida. Para el límite de tiempo es mejor que no uses tiempo real; mejor implementarlo contando el número de saltos entre habitaciones o el numero de comandos utilizados. 

* Implementa un tipo de puerta entre localizaciones que solo pueda ser cruzada una vez.

* Añadir un objeto especial al juego que puede ser cargado y disparado. Cuando cargamos ese objeto se memoriza en el la localización actual; cuando lo disparamos transporta inmediatamente al personaje a la localización memorizada. Este objeto puede ser algo que el personaje lleva con él por defecto o algún objeto que el jugador puede recoger.

* Añade puertas entre localizaciones que estén cerradas. El personaje deberá encontrar las llaves que abran dichas puertas.

* Añade una localización al juego que se comporte de la siguiente manera: cuando el jugador entra en ella es inmediatamente teletransportado a una localizaçión aleatoria. 

* Añade otros personajes además del jugador al juego. Estos personajes son similares a los items que existen actualmente pero pueden hablar. No cuentan algo la primera vez que los conoces y si les das el item adecuado te ayudan de alguna manera.



### Métodos estáticos

[Ver explicación en Youtube](http://youtu.be/OpCUHNDGdBQ)

<!--

Hasta ahora, todos los métodos que hemos utilizado son métodos pertenecientes a los objetos. Para ejecutar un método a de una clase A necesitamos invocarlo sobre un objeto de tipo A. Estos métodos que hemos venido usando hasta ahora se conocen como métodos de instancia.

Existen también lo que llamamos métodos de clase. Estos métodos pueden ser invocados sin necesidad de tener ningún objeto de esa clase. Estos métodos de clase se llaman también métodos estáticos y funcionan de forma muy parecida a las variables estáticas o de clase.

Para definir un método estatico necesitamos usar la palabra static.

Para invocar este método basta poner el nombre de la clase seguido de un punto y el método a invocar.

Como los metodos de clase están asocidados a una clase y no a los objetos de esa clase hay que tener en cuenta dos limitaciones importantes. 

La primera es que los métodos estáticos no tienen acceso a los atributos no estáticos de la clase. Esto es lógico, ya que estos atributos no estáticos están asociados con objetos individuales y es posible que el método estático se ejecute sin que haya ningún objeto de esa clase.

La segunda limitación es parecida a la primera: un método estático no puede invocar directamente métodos no estáticos.

public class Bike
{
    private int speed;    
    private static int numberOfWheels = 2;
        
    public Bike()
    {
        speed = 0;
    }
        
    public int getSpeed(){
        return speed;
    }
        
    public void applyBrake(int decrement){
        speed -= decrement;
    }
        
    public void speedUp(int increment){
        speed += increment;
    }
    
    public static int getNumberOfWheels()
    {
        return numberOfWheels;
    }
    
    public static int getSpeedStatic() {
        return getSpeed(;
    }
}
-->


### Actividad 0126

1. Echa un vistazo a la documentación de la clase `Math` disponible en `java.lang`. ¿Cuántos métodos dispone esta clase que sean no estáticos? Encuentra el método que calcula el máximo de dos números enteros y escribe en tu cuaderno su cabecera.

2. Escribe una clase `Test` que tenga un método estático que devuelva el tiempo transcurrido en mostrar por pantalla los números enteros de 1 a un millon medido en minutos y segundos. Haz uso para ello de la clase `System` del paquete `java.lang` y concretamente de su método `currentTimeMillis`.


### Actividad 0127

1. En esta actividad vamos a empezar a implementar una red social del estilo de Facebook o de Google+. En concreto nos vamos a centrar de momento en la parte relativa al muro de noticias (_news feed_), es decir, a la lista de mensajes que deberían aparecer por pantalla cuando el usuario abre la página principal de la red social.

	Inicialmente, en el feed news aparecerán solo dos tipos de entradas: entradas de texto (text posts) y entradas de foto (photo post), que contendrán una imagen y un titulo para dicha imagen.

4. Los detalles en los que estamos interesados para una entrada o post de texto son:
	+ El nombre de usuario del autor.
	+ El texto del mensaje.
	+ El momento temporal en el que fue creado (_timestamp_).
	+ Cuanta gente ha indicado que le gusta ese post.
	+ Un listado de comentarios sobre ese post hechos por otros usuarios.

3. Los detalles en los que estamos interesados para las entradas o post de foto son:
	* EL nombre de usuario del autor.
	* El nombre de archivo de la imagen a mostrar.
	* Un título para la foto.
	* El momento temporal en el que fue creado.
	* Cuánta gente ha indicado que le gusta ese post.
	* Un listado de comentarios sobre ese post hechos por otros usuarios.

4. Crea en BlueJ un nuevo proyecto llamado `social-network`, crea con `git` un repositorio en la carpeta del proyecto e implementa las tres clases que se indican en el diagrama UML que se adjunta al final del enunciado. Ten en cuenta que:

	1. Para obtener el `timestamp` debes hacer uso del método estático de la clase `System` llamado `currentTimeMillis`.

	2. En el método `display` de los objetos `MessagePost` y `PhotoPost` se deben mostrar todas las caracteristicas de las entradas. No nos interesa el momento de la creación de la entrada si no el tiempo en minutos y segundos que ha pasado desde que fue creado hasta que se esta visualizando. Además, si la entrada no tiene comentarios se debe mostrar un mensaje indicándolo.

	3. En la clase `PhotoPost` la imagen estará definida como un nombre de archivo (`filename`).

	4. Los comentarios los vamos a representar de momento como una colección de `String`. Probablemente sería más adecuado crear una clase `Comment` pero para simplificar no implementaremos aún dicha clase.

	5. Tampoco nos interesa de momento saber qué usuario ha hecho un "like" en el post en cuestión si no solo saber cuántos "like" tiene un determinado post. Por eso, almacenamos los "like" como un entero.

	6. El método `show` de la clase `NewsFeed` muestra primero los post de texto y después los post de foto.

	7. Debes utilizar ramas para desarrollar las funcionalidades pedidas. La rama principal `master` debe tener al menos 3 commits, uno por cada clase, y deben ser commits realizados en momentos en los que el código compila correctamente.

5. Una vez que has testeado que la aplicación funciona correctamente, crea desde la interfaz de BlueJ un objeto de tipo `MessagePost` e introdúcelo en un objeto de la clase `NewsFeed`. Muestra por pantalla el muro de noticias y comprueba como el post indica que no tiene comentarios. Añade ahora un comentario al objeto `MessagePost` que tienes en el banco de objetos. Cuando muestras por pantalla de nuevo el muro de noticias, tiene el post mostrado comentarios. ¿Este comportamiento era el que esperabas? Explica en tu cuaderno tu respuesta.

6. ¿Qué problemas de diseño detectas en tu codigo? Escribelos en tu cuaderno.



<div class="text-center">
<table id="uml">	
	<tr>
		<td id="nombreClase">MessagePost</td>
	</tr>
	<tr>
		<td>
		-username: String<br>
		-message: String<br>
		-timestamp: long<br>
		-likes: int<br>
		-comments: String[]<br>
		</td>
	</tr>
	<tr>
		<td>
		+MessagePost(String author, String text)<br>
		+like()<br>
		+unlike()<br>
		+addComment(String text)<br>
		+getText(): String<br>
		+getTimeStamp()<br>
		+display()<br>
		-timeString(long time): String
		</td>
	</tr>
</table>
</div> 

<div class="text-center">
<table id="uml">	
	<tr>
		<td id="nombreClase">PhotoPost</td>
	</tr>
	<tr>
		<td>
		-username: String<br>
		-filename: String<br>
		-caption: String<br>
		-timestamp: long<br>
		-likes: int<br>
		-comments: String[]<br>
		</td>
	</tr>
	<tr>
		<td>
		+PhotoPost(String author, String text)<br>
		+like()<br>
		+unlike()<br>
		+addComment(String text)<br>
		+getImageFile(): String<br>
		+getCaption(): String<br>
		+getTimeStamp()<br>
		+display()<br>
		-timeString(long time): String
		</td>
	</tr>
</table>
</div> 

<div class="text-center">
<table id="uml">	
	<tr>
		<td id="nombreClase">NewsFeed</td>
	</tr>
	<tr>
		<td>
		-messages: MessagePost[]<br>
		-photos: PhotoPost[]<br>
		</td>
	</tr>
	<tr>
		<td>
		+NewsFeed()<br>
		+addMessagePost(MessagePost message)<br>
		+addPhotoPost(PhotoPost photo)<br>
		+addComment(String text)<br>
		+show()<br>
		</td>
	</tr>
</table>
</div> 
